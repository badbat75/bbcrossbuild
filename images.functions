#!/bin/bash

check_core_functions

check_images_functions () {
	is_images_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Images functions not loaded"
		exit 1
	fi
}

function create_image() {
	# create_image <tag_name> [--rootfstype <fs_type>] [--size <size_in_KiB> [--layout <layout_file>]
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo "fail [create_image: ${STATUS}]."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${_param_1}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${_param_1}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_1}.log; \
		fi; \
		echo "Unmounting ${MOUNT_DIR}" ; \
		run_cmd -s "umount -R ${MOUNT_DIR}" >> ${LOG_PATH}/images_${_param_1}.log; \
		run_cmd -s "losetup -D" >> ${LOG_PATH}/images_${_param_1}.log; \
		return ${STATUS};' ERR

	OPTS="" OPTS_WITH_VALUE="--rootfstype --size --layout" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local IMAGE_PATH=${DISKIMAGES_PATH}/${_param_1}.img
	local MOUNT_DIR=${PLATFORM_PATH}/${_param_1}
	local ROOTFS_TYPE=${_param_rootfstype:-ext4}
	local SIZEIEC=${_param_size:-2G}

	if [ -z ${_param_layout} ]
	then
		local LAYOUT="$(cat <<-EOF
			label: dos
			unit: sectors
			sector-size: 512

			start=        8192, size=      524288, type=c
			start=      532480, type=83
			EOF
		)"
	else
		local LAYOUT="$(cat ${_param_layout})"
	fi
	echo -n "Creating image... "
	> ${LOG_PATH}/images_${_param_1}.log
	if [ ! -d ${DISKIMAGES_PATH} ]
	then
		run_cmd "mkdir -pv ${DISKIMAGES_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	fi
	#local SIZE=$( numfmt --from=iec ${SIZEIEC} )
	#local BS=$( numfmt --from=iec 1M )
	#local COUNT=$(( ${SIZE} / ${BS} ))
	#dd if=/dev/zero of=${IMAGE_PATH} bs=${BS} count=${COUNT} status=progress oflag=direct >> ${LOG_PATH}/images_${_param_1}.log 2>&1
	run_cmd "truncate -s0 ${IMAGE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd "fallocate -v -l ${SIZEIEC} ${IMAGE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd "wipefs --all --backup --force ${IMAGE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Partitioning... "
	run_cmd "echo '${LAYOUT}' | sfdisk ${IMAGE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Creating loopback devices... "
	run_cmd -s "losetup -f -P ${IMAGE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	LODEVICE=$(sudo losetup -l --raw | grep ${IMAGE_PATH} | tail -n1 | awk '{print $1}')
	echo "ok."
	#echo -n "Scanning for partitions."
	#sudo kpartx ${LODEVICE}
	echo -n "Creating filesystems... "
	run_cmd -s "mkfs.vfat ${LODEVICE}p1" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "mkfs.${ROOTFS_TYPE} ${LODEVICE}p2" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Mounting image... "
	run_cmd "mkdir -pv ${MOUNT_DIR}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "mount ${LODEVICE}p2 ${MOUNT_DIR}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "mkdir -pv ${MOUNT_DIR}/{boot,dev/pts,etc,proc}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "install -dv -m 1777 ${MOUNT_DIR}/tmp" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "mount ${LODEVICE}p1 ${MOUNT_DIR}/boot" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Creating /etc/fstab... "
	run_cmd -s "bash -c 'cat > ${MOUNT_DIR}/etc/fstab <<-EOF
		proc                 /proc proc defaults 0 0
		PARTUUID=$(sudo blkid ${LODEVICE}p1 -o value -s PARTUUID) /boot $(sudo blkid ${LODEVICE}p1 -o value -s TYPE) defaults 0 2
		PARTUUID=$(sudo blkid ${LODEVICE}p2 -o value -s PARTUUID) /     $(sudo blkid ${LODEVICE}p2 -o value -s TYPE) defaults 0 1
		EOF
		'" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Unmounting image... "
	run_cmd -s "umount -R ${MOUNT_DIR}/boot ${MOUNT_DIR}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd "rmdir ${MOUNT_DIR}" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	echo -n "Flushing loop devices... "
	run_cmd -s "losetup -D" >> ${LOG_PATH}/images_${_param_1}.log
	echo "ok."
	set +x
	trap - ERR
}

function mount_tag () {
	# mount_tag <MountPointName> [--url <URL_of_image> --imgfile <imagename_inside_archive>] \
	# --mountlist "<partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn] --resize <partnumber:size> "
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo "fail [mount_tag: ${STATUS}]."; \
		echo; \
		unmount_tag ${MOUNT_DIR}; \
		sudo losetup -D; \
		return ${STATUS};' ERR

	OPTS="" OPTS_WITH_VALUE="--url --imgfile --mountlist --resize" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local IMAGEFILE_PATH=${DISKIMAGES_PATH}/${_param_1}.img
	local MOUNT_DIR=${PLATFORM_PATH}/${_param_1}
	LODEVIMAGES[${_param_1}]=${IMAGEFILE_PATH}

	if [ -z "${_param_mountlist}" ]
	then
		echo "Error. No mount points specified."
		false
	fi

	if [ ! -d ${IMAGE_PATH} ] ; then mkdir -p ${IMAGE_PATH} ; fi

	if [ ! -z ${_param_url} ]
	then
		if [ -z ${_param_imgfile} ]
		then
			echo "--imgefile: Image name inside archive should be specified."
			return 1
		fi
		if [ ! -f ${DISKIMAGES_PATH}/${_param_1}.img ]
		then
			echo -n "Downloading and uncompress ${_param_imgfile}... "
			NODELETEDESTDIR=1 download_uncompress ${_param_url} ${DISKIMAGES_PATH} ${_param_imgfile} >> ${LOG_PATH}/images_${_param_1}.log 2>&1
			echo "done."
			run_cmd "mv -v ${DISKIMAGES_PATH}/${_param_imgfile} ${DISKIMAGES_PATH}/${_param_1}.img" >> ${LOG_PATH}/images_${_param_1}.log
		else
			echo "Image ${_param_1}.img already ready."
		fi
	fi

	if [ ! -z ${_param_resize} ]
	then
		local PARTNO=$(echo ${_param_resize} | awk -F: '{print $1}')
		local IMGSIZE=$(echo ${_param_resize} | awk -F: '{print $2}')
		# Extend the image size to ${IMGSIZE}
		echo -n "Extend image size to ${IMGSIZE}... "
		run_cmd "truncate -s ${IMGSIZE} ${IMAGEFILE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
		echo "Done."
		# Expand root partition in the image
		echo -n "Expand root partition... "
		local PARTINFO=$(sfdisk -d ${IMAGEFILE_PATH} | tail -n1)
		run_cmd "sfdisk --delete ${IMAGEFILE_PATH} ${PARTNO} >> ${LOG_PATH}/images_${_param_1}.log"
		run_cmd "echo ${PARTINFO} | sed '\$s/ size.*,//' | sfdisk --append ${IMAGEFILE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
		echo "Done."
	fi

	# Create loopback devices for the image and its partitions
	echo -n "Creating loop devices... "
	run_cmd -s "losetup -f -P ${IMAGEFILE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "losetup -j ${IMAGEFILE_PATH}" >> ${LOG_PATH}/images_${_param_1}.log
	LOOPDEV=$(sudo losetup -j ${IMAGEFILE_PATH} | awk '{print $1}' | sed 's/.$//g') >> ${LOG_PATH}/images_${_param_1}.log 2>&1
	echo | log_buffer info >> ${LOG_PATH}/images_${_param_1}.log
	echo "Loop device for ${IMAGEFILE_PATH}: ${LOOPDEV}" | log_buffer info >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "partprobe ${LOOPDEV}" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "kpartx ${LOOPDEV}" >> ${LOG_PATH}/images_${_param_1}.log
	echo "Done."


	if [ ! -z ${_param_resize} ]
	then
		# Check the root partition
		echo -n "Check root filesystems... "
		run_cmd -s "fsck -fp ${LOOPDEV}p${PARTNO}" >> ${LOG_PATH}/images_${_param_1}.log
		echo "Done."
		# Resize the root partition
		echo -n "Resize root partition... "
		run_cmd -s "resize2fs ${LOOPDEV}p${PARTNO}" >> ${LOG_PATH}/images_${_param_1}.log
		echo "Done."
	fi

	# Mount the image filesystems
	echo -n "Mounting all the partitions in ${MOUNT_DIR}... "
	for e in ${_param_mountlist}
	do
		local PARTNO=$(echo ${e} | awk -F: '{print $1}')
		local MPOINT=$(echo ${e} | awk -F: '{print $2}')
		if [ "${MPOINT}" = "/" ]
		then
			local ROOTREADY=1
			unset MPOINT
		fi
		if [ ! -d ${MOUNT_DIR}${MPOINT} ] ; then mkdir -p ${MOUNT_DIR}${MPOINT} ; fi
		run_cmd -s "fsck -fp ${LOOPDEV}p${PARTNO}" >> ${LOG_PATH}/images_${_param_1}.log
		run_cmd -s "mount ${LOOPDEV}p${PARTNO} ${MOUNT_DIR}${MPOINT}" >> ${LOG_PATH}/images_${_param_1}.log
	done
	if [ "${ROOTREADY}" -eq 1 ]
	then
		run_cmd -s "mount --bind /dev ${MOUNT_DIR}/dev" >> ${LOG_PATH}/images_${_param_1}.log
		run_cmd -s "mount -t proc /proc ${MOUNT_DIR}/proc" >> ${LOG_PATH}/images_${_param_1}.log

		if [ ! -d ${MOUNT_DIR}/tmp/bbxb ]
		then
			run_cmd "mkdir -p ${MOUNT_DIR}/tmp/bbxb" >> ${LOG_PATH}/images_${_param_1}.log
		fi
	fi
	echo "Done."
	MOUNTED_IMAGES="${MOUNTED_IMAGES} ${_param_1}"

	# Temporary configuration for mounted image
	if [ -f ${MOUNT_DIR}/etc/resolv.conf ]
	then
		echo -n "Configure local resolv.conf... "
		run_cmd -s "mv ${MOUNT_DIR}/etc/resolv.conf ${MOUNT_DIR}/etc/resolv.conf.bbxb" >> ${LOG_PATH}/images_${_param_1}.log
		run_cmd -s "cp /etc/resolv.conf ${MOUNT_DIR}/etc/resolv.conf" >> ${LOG_PATH}/images_${_param_1}.log
		echo "Done."
	fi
	set +x
	trap - ERR
}

function unmount_tag () {
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo "fail [unmount_tag: ${STATUS}]."; \
		echo; \
		return ${STATUS};' ERR

	OPTS="--all --finalize --kill" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	if [ ${_param_all:-0} -eq 1 ]
	then
		for image in ${MOUNTED_IMAGES}
		do
			unmount_tag ${_param_finalize:+--finalize} ${_param_finalize:+--kill} ${image}
		done
	else
		local MOUNT_NAME=${_param_1}
		local MOUNT_DIR=${PLATFORM_PATH}/${MOUNT_NAME}

		if [ ${_param_kill:-0} -eq 1 ]
		then
			echo -n "killing processes using ${MOUNT_DIR}... "
			local PROC="$(findmnt --raw -nRo target ${MOUNT_DIR} | xargs lsof -t -w ${MOUNT_DIR} | xargs)"
			while [ ! "${PROC}" == "" ]
			do
				echo -n "killing ${PROC}"
				run_cmd -s "kill -9 ${PROC}" >> ${LOG_PATH}/images_${MOUNT_NAME}.log
				sleep 1
				local PROC="$(findmnt --raw -nRo target ${MOUNT_DIR} | xargs lsof -t -w ${MOUNT_DIR} | xargs)"
			done
			echo -n "... "
		fi

		echo -n "Unmounting ${MOUNT_DIR}... "
		# Restore configuration for mounted image
		if [ -f ${MOUNT_DIR}/etc/resolv.conf.bbxb ]
		then
			run_cmd -s "mv ${MOUNT_DIR}/etc/resolv.conf.bbxb ${MOUNT_DIR}/etc/resolv.conf" >> ${LOG_PATH}/images_${MOUNT_NAME}.log
		fi
		# Unmount everything
		echo "Unmounting ${MOUNT_DIR}... " | log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log		
		local STATUS=1
		while [ ! ${STATUS} -eq 0 ]
		do
			if mountpoint -q ${MOUNT_DIR}
			then
				run_cmd -s "umount -fR ${MOUNT_DIR}" >> ${LOG_PATH}/images_${MOUNT_NAME}.log && local STATUS=0 || local STATUS=1
			else
				STATUS=0
			fi
			case ${STATUS} in
				0)
					echo "done." | log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log 2>&1
					;;
				*)
					echo "failed, sleeping... " | log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log 2>&1
					echo "Current DIR: ${PWD}"| log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log
					local ACTIVE_MOUNTS="$(findmnt --raw -nRo target ${MOUNT_DIR} | xargs)"
					echo "Current active mounts: ${ACTIVE_MOUNTS}" | log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log
					echo "Current active processes: $(echo ${ACTIVE_MOUNTS} | xargs lsof -t -w | xargs)" | log_buffer info >> ${LOG_PATH}/images_${MOUNT_NAME}.log
					sleep 1
					;;
			esac
		done
		MOUNTED_IMAGES=$(echo ${MOUNTED_IMAGES} | sed "s/ *${MOUNT_NAME}//")
		# Delete the loopback devices
		echo -n "Delete loopback device... "
		run_cmd -s "losetup -D ${LOOPDEV}" >> ${LOG_PATH}/images_${MOUNT_NAME}.log
		echo "Done."
	fi

	if [ ${_param_finalize:-0} -eq 1 ]
	then
		mv ${LODEVIMAGES[${MOUNT_NAME}]} ${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${PRJ_NAME}.img
		run_cmd "cat >${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${PRJ_NAME}.dd <<-EOF
			#!/bin/bash
			sudo dd if=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${PRJ_NAME}.img of=\\\${1:-/dev/mmcblk0} bs=1M status=progress oflag=direct
		EOF
		" >> ${LOG_PATH}/images_${MOUNT_NAME}.log
		run_cmd "chmod +x ${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${PRJ_NAME}.dd" >> ${LOG_PATH}/images_${MOUNT_NAME}.log
	fi

	echo
	set +x
	trap - ERR
}

function mount_from () {
	# mount_from --url <URL> --imgfile <Image2Mount> --tag <MountPointName> --resize <partnumber:size> \
	#	--mountlist "<partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn]"
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo "fail [mount_from]."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${_param_tag}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${_param_tag}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_tag}.log; \
		fi; \
		return ${STATUS};' ERR

	OPTS="" OPTS_WITH_VALUE="--url --imgfile --tag --mountlist --resize" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	if [ ! -d ${DISKIMAGES_PATH} ] ; then mkdir -p ${DISKIMAGES_PATH} ; fi
	if [ ! -f ${DISKIMAGES_PATH}/${_param_tag}.img ]
	then
		echo -n "Downloading and uncompress ${_param_imgfile}... "
		NODELETEDESTDIR=1 download_uncompress ${_param_url} ${DISKIMAGES_PATH} ${_param_imgfile} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "done."
		mv ${DISKIMAGES_PATH}/${_param_imgfile} ${DISKIMAGES_PATH}/${_param_tag}.img
	else
		echo "Image ${_param_tag}.img already ready."
	fi
	echo -n "Mounting ${_param_imgfile} to ${_param_tag} as ${_param_tag}.img... "
	# mount_from --tag <MountPointName> --resize <partnumber:size> --mountlist <partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn]

	mount_tag "${_param_tag}" --mountlist "${_param_mountlist}" --resize "${_param_resize}"
	echo "done."
	echo
	set +x
	trap - ERR
}

function run_on_root_dir () {
	# run_on_root_dir <mount tag> <user> "<command>"
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo; \
		echo "fail [run_on_root_dir]."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${_param_1}.log ]; \
		then \
			echo "Log ${LOG_PATH}/images_${_param_1}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_1}.log; \
		fi; \
		return ${STATUS};' ERR
			
	OPTS="--allocate_pty" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local CHROOT_DIR=$(echo ${_param_1} | sed 's/^//g')
	local CHROOT_PROMPT=${_param_2}
	local CHROOT_PWD=$(sudo chroot ${PLATFORM_PATH}/${_param_1} su - ${_param_2} -c "pwd")
	local CHROOT_PROMPT="${_param_2}:${CHROOT_PWD}"

	if [ ${_param_2} = "root" ]
	then
		local CHROOT_PROMPT+='# '
	else
		local CHROOT_PROMPT+='$ '
	fi
	echo "${CHROOT_PROMPT}${_param_3}" | log_buffer >> ${LOG_PATH}/images_${_param_1}.log
	sudo chroot ${PLATFORM_PATH}/${_param_1} su - $( [ ${_param_allocate_pty:-0} -eq 1 ] && echo "--pty" || true ) \
		${_param_2} -c "${_param_3}" 2> >(log_buffer error ${LOG_PATH}/images_${_param_1}.log) > >(log_buffer log ${LOG_PATH}/images_${_param_1}.log)
	echo | log_buffer >> ${LOG_PATH}/images_${_param_1}.log

	[ ${_param_v:-0} -eq 1 ] && set +x || true
	trap - ERR
}

function inject_into_mount_tag () {
	# inject_into_mount_tag <mount_tag> <object> <directory> <owner>
	#   mount_tag: name of the mount tag
	#   object:
	#		binary: copy the built binary targets into mount tag
	#		<filename>: copy the filename into mount tag
	#	directory: directory where to copy under mount_tag
	#   owner: file ownership (default: "root:root")

	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo; \
		echo "fail [inject_into_mount_tag: ${STATUS}]."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${ROOT_DIR}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${ROOT_DIR}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${ROOT_DIR}.log; \
		fi; \
		return ${STATUS};' ERR

	OPTS="--remove_devfiles" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local ROOT_DIR=$(echo ${_param_1} | sed 's/^//g')
	local OBJECT=${_param_2}
	local TARGET_DIR=$(echo ${_param_3} | sed 's/^//g')
	local TARGET_OWNER=${_param_4:-"root:root"}
	local TARGET_PATH=${PLATFORM_PATH}/${ROOT_DIR}${TARGET_DIR}

	setbuildenv

	case ${OBJECT} in
		binaries)
			local SOURCE_PATH=${PLATFORM_PATH}/binaries
			local TARGET_FILE=*
			;;
		#gcclibs)
		#	local GCCLIB=$(find ${GCCSEARCHLIBS} -maxdepth 1 \( -name 'libgcc_s.so*' -o -name 'libssp.so*' -o -name 'libstdc++.so.*' ! -name 'libstdc++.so.*-*.py' \) 2>/dev/null )
		#	local GCCLIBNAME="$( ( for name in ${GCCLIB}; do echo $(basename ${name}); done ) | sort | uniq )"
		#	local GCCLIBPATH="$( ( for name in ${GCCLIB}; do echo $(dirname ${name}); done ) | sort | uniq )"
		#	local TARGET_FILE="${GCCLIBNAME}"
		#	local SOURCE_PATH="${GCCLIBPATH}"
		#	local TARGET_DIR="${TARGET_DIR:-${BUILD_LIBDIR}${BUILD_LIBSUFFIX}}"
		#	;;
		*)
			local TARGET_FILE=$(basename ${OBJECT})
			local SOURCE_PATH=$(dirname ${OBJECT})
			;;
	esac

	echo "Source path: ${SOURCE_PATH}" | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log
	echo "Target path: ${TARGET_PATH}" | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log
	echo -e "Target files:\n${TARGET_FILE}\n" | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log

	echo -n "Injecting ${OBJECT} into ${ROOT_DIR}${TARGET_DIR}... "
	# [ ${_param_remove_devfiles:-0} -eq 1 ] && remove_devfiles no-exitstatus || true
	if [ ${_param_remove_devfiles:-0} -eq 1 ]
	then
		local RSYNC_EXCLUDE="--exclude ${BUILD_INCLUDEDIR} --exclude ${BUILD_LIBDIR}${BUILD_LIBSUFFIX}/cmake --exclude ${BUILD_LIBDIR}${BUILD_LIBSUFFIX}/pkgconfig --exclude *.a --exclude *.la"
	fi
	if [ ! -d ${TARGET_PATH} ]
	then
		run_cmd -s "mkdir -p ${TARGET_PATH}" >> ${LOG_PATH}/images_${ROOT_DIR}.log
		run_cmd -s "chown -h ${TARGET_OWNER} ${TARGET_PATH}" >> ${LOG_PATH}/images_${ROOT_DIR}.log
	fi
	echo -n "Syncing ${SOURCE_PATH} to ${TARGET_PATH}... " | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log
	cd ${SOURCE_PATH}
	run_cmd -s "rsync -K -a ${RSYNC_EXCLUDE} --devices --specials --no-owner --no-group ${TARGET_FILE} ${TARGET_PATH}" >> ${LOG_PATH}/images_${ROOT_DIR}.log
	cd - | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log
	echo -e "Done.\n" | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log
	echo -n "Setting ownership... "
	function set_ownership () {
		### set_ownership <owner:group> <target_directory> <copy_ownership_from_directory> <file>
		if [ -e "${2}/${3}" ]
		then
			chown -h ${1} "${2}/${3}"	
			# Check SUID from source path to change it on destination path
			if [ -u "${4}/${3}" ]
			then
				chmod -v u+s "${2}/${3}"
			fi
			if [ -g "${4}/${3}" ]
			then
				chmod -v g+s "${2}/${3}"
			fi
		else
			echo "${2}/${3} does not exists" >&2
		fi
	}
	export -f set_ownership
	case ${OBJECT} in
		binaries)
			run_cmd -S "$(declare -f set_ownership); export -f set_ownership; find ${BIN_PATH} -printf '%P\n' | xargs -I{} -d'\n' -n1 -P${NPROCS} bash -c \\
				'set_ownership ${TARGET_OWNER} \"${TARGET_PATH}\" \"{}\" \"${BIN_PATH}\"' \\
			" >> ${LOG_PATH}/images_${ROOT_DIR}.log
			;;
		*)
			run_cmd -S "$(declare -f set_ownership); export -f set_ownership; echo '${TARGET_FILE}' | xargs -I{} -d'\n' -n1 -P${NPROCS} bash -c \\
				'set_ownership ${TARGET_OWNER} \"${TARGET_PATH}\" \"{}\" \"${OBJECT}\"' \\
			" >> ${LOG_PATH}/images_${ROOT_DIR}.log
			;;
	esac

	echo "Done."
	echo | log_buffer info >> ${LOG_PATH}/images_${ROOT_DIR}.log

	set +x
	trap - ERR
}

function run_postinstall_scripts () {
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		echo; \
		echo "fail [run_postinstall_scripts]."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${_param_1}.log ]; \
		then \
			echo "Log ${LOG_PATH}/images_${_param_1}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_1}.log; \
		fi; \
		return ${STATUS};' ERR
			
	OPTS="" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	echo "Running post install scripts on ${_param_1}... " | log_buffer info >> ${LOG_PATH}/images_${_param_1}.log
	export PLATFORM_PATH LOG_PATH
	export -f param2value run_on_root_dir
	find ${PLATFORM_PATH}/${_param_1}/postinst_scripts -type f -printf '%P\n' | sort -n | xargs -I{} bash -c "run_on_root_dir ${_param_1} root 'set -x; source /postinst_scripts/{}'" >> ${LOG_PATH}/images_${_param_1}.log
	run_cmd -s "rm -rfv ${PLATFORM_PATH}/${_param_1}/postinst_scripts" >> ${LOG_PATH}/images_${_param_1}.log
	echo "Done." | log_buffer info >> ${LOG_PATH}/images_${_param_1}.log
	[ ${_param_v:-0} -eq 1 ] && set +x || true
	trap - ERR
}

unset LODEVIMAGES
unset MOUNTPOINTS
declare -A LODEVIMAGES
declare -A MOUNTPOINTS

MOUNTED_IMAGES=""

is_images_functions () {
	return 0
}
