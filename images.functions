#!/bin/bash

check_core_functions

check_images_functions () {
	is_images_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Images functions not loaded"
		exit 1
	fi
}

function mount_image () {
	# mount_from --tag <MountPointName> --resize <partnumber:size> --mountlist "<partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn]"
	trap 'STATUS=${?}; \
		set +x; \
		trap - ERR; \
		unmount_tag ${MOUNT_DIR}
		return ${STATUS};' ERR

	OPTS="" OPTS_WITH_VALUE="--tag --mountlist --resize" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local IMAGEFILE_PATH=${DISKIMAGES_PATH}/${_param_tag}.img
	local MOUNT_DIR=${PLATFORM_PATH}/${_param_tag}
	LODEVIMAGES[${_param_tag}]=${IMAGEFILE_PATH}

	if [ -z "${_param_mountlist}" ]
	then
		echo "Error. No mount points specified."
		false
	fi

	if [ ! -d ${IMAGE_PATH} ] ; then mkdir -p ${IMAGE_PATH} ; fi

	if [ ! -z ${_param_resize} ]
	then
		local PARTNO=$(echo ${_param_resize} | awk -F: '{print $1}')
		local IMGSIZE=$(echo ${_param_resize} | awk -F: '{print $2}')
		# Extend the image size to ${IMGSIZE}
		echo -n "Extend image size to ${IMGSIZE}..."
		truncate -s ${IMGSIZE} ${IMAGEFILE_PATH} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "Done."
		# Expand root partition in the image
		echo -n "Expand root partition..."
		local PARTINFO=$(sfdisk -d ${IMAGEFILE_PATH} | tail -n1)
		sfdisk --delete ${IMAGEFILE_PATH} ${PARTNO} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo ${PARTINFO} | sed '$s/ size.*,//' | sfdisk --append ${IMAGEFILE_PATH} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "Done."
	fi

	# Create loopback devices for the image and its partitions
	echo -n "Creating loop devices..."
	sudo losetup -f -P ${IMAGEFILE_PATH} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	LOOPDEV=$(sudo losetup -j ${IMAGEFILE_PATH} | awk '{print $1}' | sed 's/.$//g') >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	sudo partprobe ${LOOPDEV} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	echo "Done."

	if [ ! -z ${_param_resize} ]
	then
		# Check the root partition
		echo -n "Check root filesystems..."
		sudo e2fsck -fp ${LOOPDEV}"p"${PARTNO} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "Done."
		# Resize the root partition
		echo -n "Resize root partition..."
		sudo resize2fs ${LOOPDEV}"p"${PARTNO} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "Done."
	fi

	# Mount the image filesystems
	echo -n "Mounting all the partitions in ${MOUNT_DIR}..."
	for e in ${_param_mountlist}
	do
		local PARTNO=$(echo ${e} | awk -F: '{print $1}')
		local MPOINT=$(echo ${e} | awk -F: '{print $2}')
		if [ "${MPOINT}" = "/" ]
		then
			local ROOTREADY=1
			unset MPOINT
		fi
		MOUNTPOINTS[${MOUNT_DIR}]="${MOUNT_DIR}${MPOINT} ${MOUNTPOINTS[${MOUNT_DIR}]}"
		if [ ! -d ${MOUNT_DIR}${MPOINT} ] ; then mkdir -p ${MOUNT_DIR}${MPOINT} ; fi
		sudo mount ${LOOPDEV}"p"${PARTNO} ${MOUNT_DIR}${MPOINT} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	done
	if [ "${ROOTREADY}" -eq 1 ]
	then
		#sudo mount -t tmpfs -o nosuid,nodev,mode=755 /run ${MOUNT_DIR}/run >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		sudo mount -t devpts /dev/pts ${MOUNT_DIR}/dev/pts >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		sudo mount -t proc /proc ${MOUNT_DIR}/proc >> ${LOG_PATH}/images_${_param_tag}.log 2>&1

		if [ ! -d ${MOUNT_DIR}/tmp/bbxb ]
		then
			mkdir -p ${MOUNT_DIR}/tmp/bbxb
		fi
		sudo mount -o bind $(readlink -m ${MOUNT_DIR}/..) ${MOUNT_DIR}/tmp/bbxb
		#MOUNTPOINTS[${MOUNT_DIR}]="${MOUNT_DIR}/proc ${MOUNT_DIR}/dev/pts ${MOUNT_DIR}/run ${MOUNT_DIR}/tmp/bbxb ${MOUNTPOINTS[${MOUNT_DIR}]}"
		MOUNTPOINTS[${MOUNT_DIR}]="${MOUNT_DIR}/proc ${MOUNT_DIR}/dev/pts ${MOUNT_DIR}/tmp/bbxb ${MOUNTPOINTS[${MOUNT_DIR}]}"
	fi
	echo "Done."
	MOUNTED_IMAGES="${MOUNTED_IMAGES} ${_param_tag}"

	# Temporary configuration for mounted image
	echo -n "Configure local resolv.conf..."
	sudo mv ${MOUNT_DIR}/etc/resolv.conf ${MOUNT_DIR}/etc/resolv.conf.bbxb >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	sudo cp /etc/resolv.conf ${MOUNT_DIR}/etc/resolv.conf >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
	echo "Done."
	set +x
	trap - ERR
}

function mount_from () {
	# mount_from --url <URL> --imgfile <Image2Mount> --tag <MountPointName> --resize <partnumber:size> \
	#	--mountlist "<partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn]"
	trap 'STATUS=${?}; \
		echo "$0 fail."; \
		echo; \
		if [ -f ${LOG_PATH}/images_${_param_tag}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${_param_tag}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_tag}.log; \
		fi; \
		set +x; \
		trap - ERR; \
		return ${STATUS};' ERR

	OPTS="" OPTS_WITH_VALUE="--url --imgfile --tag --mountlist --resize" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	if [ ! -d ${DISKIMAGES_PATH} ] ; then mkdir -p ${DISKIMAGES_PATH} ; fi
	if [ ! -f ${DISKIMAGES_PATH}/${_param_tag}.img ]
	then
		echo -n "Downloading and uncompress ${_param_imgfile}..."
		NODELETEDESTDIR=1 download_uncompress ${_param_url} ${DISKIMAGES_PATH} ${_param_imgfile} >> ${LOG_PATH}/images_${_param_tag}.log 2>&1
		echo "done."
		mv ${DISKIMAGES_PATH}/${_param_imgfile} ${DISKIMAGES_PATH}/${_param_tag}.img
	else
		echo "Image ${_param_tag}.img already ready."
	fi
	echo -n "Mounting ${_param_imgfile} to ${_param_tag} as ${_param_tag}.img..."
	# mount_from --tag <MountPointName> --resize <partnumber:size> --mountlist <partnumber1:/> [partnumber2:mountpoint2]...[partnumbern:mountpointn]

	mount_image --resize "${_param_resize}" -tag "${_param_tag}" --mountlist "${_param_mountlist}"
	echo "done."
	echo
	set +x
	trap - ERR
}

function unmount_tag () {
	trap 'STATUS=${?}; \
		echo "$0 fail [unmount_tag]."; \
		echo; \
		set +x; \
		trap - ERR; \
		return ${STATUS};' ERR

	OPTS="--all --finalize --kill" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local MOUNT_DIR=${PLATFORM_PATH}/${_param_1}

	echo -n "Unmounting ${_param_1}..."

	if [ ${_param_kill:-0} -eq 1 ]
	then
		echo -n "killing processes using filesystem..."
		local PROC="$(lsof -t -w ${MOUNT_DIR} | xargs)"
		while [ ! "${PROC}" == "" ]
		do
			echo -n "killing ${PROC}"
			sudo kill -9 ${PROC}
			sleep 1
			local PROC="$(lsof -t -w ${MOUNT_DIR} | xargs)"
		done
		echo -n "..."
	fi

	if [ ${_param_all:-0} -eq 1 ]
	then
		for image in ${MOUNTED_IMAGES}
		do
			unmount_tag ${_param_finalize:+--finalize} ${_param_finalize:+--kill} ${image}
		done
	else
		# Restore configuration for mounted image
		echo -n "Restore local resolv.conf..."
		if [ -f ${MOUNT_DIR}/etc/resolv.conf.bbxb ]
		then
			sudo mv ${MOUNT_DIR}/etc/resolv.conf.bbxb ${MOUNT_DIR}/etc/resolv.conf >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
		fi
		# Unmount everything
		echo -n "Unmount all partitions..."
		if [ "x${MOUNTPOINTS[${MOUNT_DIR}]}" != "x" ]
		then
			for dir in ${MOUNTPOINTS[${MOUNT_DIR}]}
			do
				echo -n "Unmounting ${dir}..." >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
				local STATUS=1
				while [ ! ${STATUS} -eq 0 ]
				do
					sudo umount -f ${dir} >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
					local STATUS=${?}
					case ${STATUS} in
						0)
							echo "done." >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
							;;
						*)
							echo "failed ${STATUS}, sleeping..." >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
							sleep 1
							;;
					esac
				done
			done
		fi
		MOUNTED_IMAGES=$(echo ${MOUNTED_IMAGES} | sed "s/ *${MOUNTPOINTNAME}//")
		# Delete the loopback devices
		echo -n "Delete loopback device..."
		sudo losetup -D ${LOOPDEV} >> ${LOG_PATH}/images_${MOUNTPOINTNAME}.log 2>&1
		echo "Done."
	fi

	[ ${_param_finalize:-0} -eq 1 ] && mv ${LODEVIMAGES[${_param_1}]} ${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${PRJ_NAME}.img || true

	echo
	set +x
	trap - ERR
}

function run_on_root_dir () {
	# run_on_root_dir <mount tag> <user> "<command>"
	trap 'STATUS=${?}; \
		echo; \
		echo "fail [run_on_root_dir]." >> ${LOG_PATH}/images_${_param_1}.log; \
		echo; \
		set +x; \
		trap - ERR; \
		if [ -f ${LOG_PATH}/images_${_param_1}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${_param_1}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${_param_1}.log; \
		fi; \
		return ${STATUS};' ERR
			
	OPTS="" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local CHROOT_DIR=$(echo ${_param_1} | sed 's/^//g')
	local CHROOT_PROMPT=${_param_2}
	local CHROOT_PWD=$(sudo chroot ${PLATFORM_PATH}/${_param_1} su - ${_param_2} -c "pwd")
	local CHROOT_PROMPT="${_param_2}:${CHROOT_PWD}"

	if [ ${_param_2} = "root" ]
	then
		local CHROOT_PROMPT+='# '
	else
		local CHROOT_PROMPT+='$ '
	fi
	echo "${CHROOT_PROMPT}${_param_3}" >> ${LOG_PATH}/images_${_param_1}.log 2>&1
	sudo chroot ${PLATFORM_PATH}/${_param_1} su - --pty ${_param_2} -c \
		"${_param_3}" >> ${LOG_PATH}/images_${_param_1}.log 2>&1
	echo >> ${LOG_PATH}/images_${_param_1}.log 2>&1

	set +x
	trap - ERR
}

function inject_into_mount_tag () {
	trap 'STATUS=${?}; \
		echo "fail. Unmounting ${ROOT_DIR}."; \
		echo; \
		set +x; \
		trap - ERR; \
		if [ -f ${LOG_PATH}/images_${ROOT_DIR}.log ];
		then \
			echo "Log ${LOG_PATH}/images_${ROOT_DIR}.log:"; \
			echo; \
			tail -n24 ${LOG_PATH}/images_${ROOT_DIR}.log; \
		fi; \
		return ${STATUS};' ERR

	OPTS="--remove_devfiles" OPTS_WITH_VALUE="" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true

	local ROOT_DIR=$(echo ${_param_1} | sed 's/^//g')
	local OBJECT=${_param_2}
	local TARGET_DIR=$(echo ${_param_3} | sed 's/^//g')
	local TARGET_OWNER=${_param_4:-"root:root"}

	case ${OBJECT} in
		sfx_archive)
			local TARGET_FILE=${PRJ_NAME}.sfx
			local SOURCE_PATH=${PLATFORM_PATH}
			;;
		archive)
			local TARGET_FILE=${PRJ_NAME}.tar.xz
			local SOURCE_PATH=${PLATFORM_PATH}
			;;
		binaries)
			local TARGET_FILE=*
			local SOURCE_PATH=${PLATFORM_PATH}/binaries
			;;
		*)
			local TARGET_FILE=$(basename ${OBJECT})
			local SOURCE_PATH=$(dirname ${OBJECT})
			;;
	esac

	echo -n "Injecting ${TARGET_FILE} into ${TARGET_DIR:-/}..."
	[ ${_param_remove_devfiles:-0} -eq 1 ] && remove_devfiles no-exitstatus || true
	if [ ! -d ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR} ]
	then
		sudo mkdir -p ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR} >> ${LOG_PATH}/images_${ROOT_DIR}.log 2>&1
		echo -n "setting ownership of ${TARGET_OWNER} on ${TARGET_DIR}..."
		sudo chown -h ${TARGET_OWNER} ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR} >> ${LOG_PATH}/images_${ROOT_DIR}.log 2>&1
	fi
	#sudo cp -fr --preserve=mode,timestamps ${SOURCE_PATH}/${TARGET_FILE} ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR} >> ${LOG_PATH}/images_${ROOT_DIR}.log 2>&1
	cd ${SOURCE_PATH}
	sudo rsync -K -a --no-owner --no-group ${TARGET_FILE} ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR} >> ${LOG_PATH}/images_${ROOT_DIR}.log 2>&1
	cd -
	echo -n "setting ownership of ${TARGET_OWNER} on ${TARGET_FILE}..."
	case ${OBJECT} in
		binaries)
			find ${BIN_PATH} -printf "${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR}%P\n" | xargs -d'\n' -n1 -P${NPROCS} sudo chown -h ${TARGET_OWNER}
			;;
		*)
			sudo chown -hR ${TARGET_OWNER} ${PLATFORM_PATH}/${ROOT_DIR}/${TARGET_DIR}/${TARGET_FILE} >> ${LOG_PATH}/images_${ROOT_DIR}.log 2>&1
			;;
	esac
	[ ${_param_remove_devfiles:-0} -eq 1 ] && resume_devfiles no-exitstatus || true

	echo "done."
	echo

	set +x
	trap - ERR
}

unset LODEVIMAGES
unset MOUNTPOINTS
declare -A LODEVIMAGES
declare -A MOUNTPOINTS

MOUNTED_IMAGES=""

is_images_functions () {
	return 0
}
