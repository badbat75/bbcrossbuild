#!/bin/bash

check_core_functions () {
	is_core_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Core functions not loaded"
		exit 1
	fi
}

param2value () {
	
	# Requires at least one OPTS or OPTS_WITH_VALUE to run
	# OPTS="-a -b -c" OPTS_WITH_VALUE="-d" param2value "${@}"

	local OPTS+=" -v "
	local NUM=0

	unset $( ( set -o posix ; set ) | grep ^_param_ | sed 's/=.*$//g' | xargs )

	while(($#)) ; do
		if [[ ${1} == -* ]]
		then
			if [ "${1} " == "$(echo ${OPTS} ${OPTS_WITH_VALUE} | grep -o -- "${1} ")" ]
				then
					local OPTION=${1}
					local PARAMETER=$(echo ${1} | sed -e 's/^--\?//;s/-/_/g')
					if [ "${1} " == "$(echo ${OPTS_WITH_VALUE} | grep -o -- "${1} ")" ]
					then
						shift
						if [ ! "x${1}" == "x" ]
						then 
							eval "_param_${PARAMETER}='${1}'"
						else
							echo "${OPTION} unset, no assigned value."
							return 1
						fi
					else
						eval "_param_${PARAMETER}=1"
					fi
			else
				echo "Unrecognized option: ${1}"
				return 1
			fi
		else
				local NUM=$((NUM+1))
				eval "_param_${NUM}='${1}'"
				local PARAMETER=${NUM}
		fi
		[ ${_param_v:-0} -eq 1 ] && eval echo "_param_${PARAMETER}=\$_param_${PARAMETER}" || true
		shift
	done
}

download_uncompress () {
	## download_uncompress <URLs> <destination> [files_to_extract]
	## STRIPCOMPONENTS=<num>: Add strip --strip-components=<n> to tar command
	## ARCHIVEDIRS=<str>: Specify what directories to extract
	## NODELETEDESTDIR=<num>: if 1 don't delete ${DEST_DIR}

	trap 'STATUS=${?}; \
		echo "download_uncompress fail."; \
		trap - ERR; \
		return ${STATUS};' ERR

	local URL=${1}
	local URL_HASH=$(echo -n "${URL}" | md5sum -t | awk '{print $1}')
	local DEST_DIR=${2}
	shift 2
	local FILES2EXTRACT="${@}"
	local STRIPCOMPONENTS=${STRIPCOMPONENTS:-1}
	local NODELETEDESTDIR=${NODELETEDESTDIR:-0}
	if [ ${STRIPCOMPONENTS} -gt 0 ]
	then
		local TARFLAGS="--strip-components=${STRIPCOMPONENTS}"
	fi
	if [ ! -d ${DOWNLOAD_PATH} ]
	then
		run_cmd "mkdir -pv ${DOWNLOAD_PATH}"
	fi
	if [ -f "${DOWNLOAD_PATH}/url2file.map" ]
	then
		run_cmd "touch ${DOWNLOAD_PATH}/url2file.map"
	fi
	local HASH_ROW=$(grep ${URL_HASH} "${DOWNLOAD_PATH}/url2file.map")
	# if download file does not exists in database download package
	if [ -z "${HASH_ROW}" ]
	then
		echo "\$ curl -k -vLsI -o /dev/null ${URL}"
		local DOWNLOAD_FILE="$(curl -k -vLsI -o /dev/null ${URL} 2>&1 | egrep -i '^< content-disposition:' | tr -d "\n\r" | sed -e 's/^.*filename="\?//;s/".*//')"
		if [ -z ${DOWNLOAD_FILE} ]
		then
			local DOWNLOAD_FILE="$(basename ${URL})"
		else
			local DOWNLOAD_FILE="$(basename ${DOWNLOAD_FILE})"
		fi
		local DOWNLOAD_HASH_FILE="${URL_HASH}_$(basename ${DOWNLOAD_FILE})"
		echo "${URL_HASH} ${DOWNLOAD_FILE}" >> ${DOWNLOAD_PATH}/url2file.map
	else
	local DOWNLOAD_HASH_FILE=$(echo ${HASH_ROW} | awk '{print $1 "_" $2}')
	local DOWNLOAD_FILE=$(echo ${HASH_ROW} | awk '{print $2}')
	fi
	# if download file does not exists in filesystem
	if [ ! -f "${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE}" ]
	then
		run_cmd "curl -k -LsR -o ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} \"${URL}\""
	fi
	if [ -d ${DEST_DIR} ] && [ ${NODELETEDESTDIR} -eq 0 ]
	then
		run_cmd "rm -rf ${DEST_DIR}"
	fi
	local FILE_ENCODING=$(file -iz ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE})
	local DOWNLOAD_FILE_TYPE=$(echo ${FILE_ENCODING} | egrep -o "compressed-encoding=[^;]*" | sed 's/compressed-encoding=//')
	local UNCOMPRESSED_FILE_TYPE=$(echo ${FILE_ENCODING} | awk '{print $2}' | sed 's/;$//')
	if [ ! -d ${DEST_DIR} ] ; then run_cmd "mkdir -pv ${DEST_DIR}" ; fi
	case ${UNCOMPRESSED_FILE_TYPE} in
		application/x-tar)
			run_cmd "tar xf ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} ${TARFLAGS} -C ${DEST_DIR} ${ARCHIVE_DIRS}"
			;;
		*)
			case ${DOWNLOAD_FILE_TYPE} in
				application/x-xz)
					run_cmd "cp ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} ${DEST_DIR}/${DOWNLOAD_FILE}"
					run_cmd "xz --uncompress ${DEST_DIR}/${DOWNLOAD_FILE}"
					;;
				application/zip)
					if [ -z "${FILES2EXTRACT}" ]
					then
						run_cmd "unzip -n ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} -d ${DEST_DIR}"
					else
						run_cmd "unzip -j -n ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} "${FILES2EXTRACT}" -d ${DEST_DIR}"
					fi
					;;
				*)
					run_cmd "cp ${DOWNLOAD_PATH}/${DOWNLOAD_HASH_FILE} ${DEST_DIR}/${DOWNLOAD_FILE}"
					;;
			esac
			;;
	esac
	trap ERR
}

test_version () {
	test -z ${3} && echo "I need 2 arguments to compare and an operator." && return 255

	local SORTED="$(echo -e "${1}\n${3}" | sort -Vru -)"
	local BIGGEST="$(echo -e "${SORTED}" | head -n1)"
	local NO=$(echo -e "${SORTED}" | wc -l)

	case ${2} in
		-gt)
			if [ "${BIGGEST}" == "${1}" ] && [ ${NO} -gt 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-ge)
			if [ "${BIGGEST}" == "${1}" ]
			then
					return 0
			else
					return 1
			fi
		;;
		-lt)
			if [ "${BIGGEST}" != "${1}" ] && [ ${NO} -gt 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-le)
			if [ "${BIGGEST}" != "${1}" ] || [ ${NO} -eq 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-eq)
			if [ ${NO} -eq 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-ne)
			if [ ${NO} -eq 2 ]
			then
					return 0
			else
					return 1
			fi
		;;
		*)
			echo "No valid operator specified!"
			return 255
		;;
	esac	
}

pause () {
	echo
	read -n 1 -s -r -p "Press any key to continue..."
	echo
}

pathadd () {

	### pathadd <PATH|LD_LIBRARY_PATH> <path-name>

	if [ -z "${1}" ]
	then
		echo "Variable not defined."
		return 1
	fi

	if [ -z "${2}" ]
	then
		echo "Path not defined."
		return 1
	fi

	eval "
	while read sp
	do
		if [ \"\${sp}\" == \"\${2}\" ]
		then
			#echo "\${2} already found in \${1}"
			return 0
		fi
	done < <(tr ':' '\n' <<< \"\${${1}}\")

	if [ -z \"\${${1}}\" ]
	then
		export ${1}="\${2}"
	else
		export ${1}="\${2}:\${${1}}"
	fi
	#echo "\${2} added to \${1}"
	"
}

pathremove () {

	### pathremove <PATH|LD_LIBRARY_PATH> <path-name>

	if [ -z "${1}" ]
	then
		echo "Variable not defined."
		return 1
	fi

	if [ -z "${2}" ]
	then
		echo "Path not defined."
		return 1
	fi

	local i=1
	local FPATH=
	local FOUND=0

	eval "
	while read sp
	do
		if [ \"\${sp}\" != \"\${2}\" ]
		then
			local FPATH+=\"\$( [ \$i -gt 1 ] && echo \":\" )\${sp}\"
			let \"i+=1\"
		else
			local FOUND=1
		fi
	done < <(tr ':' '\n' <<< \"\${${1}}\")

	if [ \${FOUND} -eq 1 ]
	then
		export ${1}=\"\${FPATH}\"
		#echo \"\${2} removed from PATH\"
	#else
		#echo \"\${2} not found in PATH\"
	fi
	"
}

log_buffer () {
	(
		unset IFS
		local LOG_TYPE="${1:-log}"
		local LOG_FILE="${2:-/dev/stdout}"
		case ${LOG_TYPE} in
			cmd)    local LOG_CHAR='$';;
			info)   local LOG_CHAR='#';;
			log)    local LOG_CHAR='-';;
			status) local LOG_CHAR='=';;
			error)  local LOG_CHAR='!';;
			*)      local LOG_CHAR="${LOG_TYPE}";;
		esac
		while read -r line
		do
			printf "%s - [%s]${LOG_CHAR} %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$(basename ${PWD})" "${line}" >> ${LOG_FILE}
		done < /dev/stdin
	)
}

run_cmd () {
	trap 'STATUS=${PIPESTATUS[0]}; \
		trap - ERR; \
		trap - SIGINT; \
		echo -e "\nERR caught. [run_cmd: ${STATUS}]" >&2;  \
		echo -e "Command: ${CMDLINE}\n" >&2; \
		return ${STATUS};' ERR
	trap 'echo "SIGINT caught. [run_cmd]"; \
		trap - ERR; \
		trap - SIGINT; \
		return 100;' SIGINT
	
	unset RUNCMD_SUDO
	case "${1}" in
		"-S") 
			local RUNCMD_SUDO="sudo/bash"
			shift
			;;
		"-s")
			local RUNCMD_SUDO="sudo"
			shift
			;;
	esac
	local CMDLINE="${@}"
	local STATUS=255
	local RETRIES=0
	local LOG_PROMPT="[$(basename ${PWD})]"
	while [ ${STATUS} -ne 0 ] && [ ${RETRIES} -lt ${MAX_RETRIES:-1} ]
	do
		local RETRIES=$((RETRIES+1))
		if [ ${RETRIES} -gt 1 ]
		then
			# Sleep random between 6 and 10 seconds
			sleep $((6 + $RANDOM % 5))
			echo "Try ${RETRIES}" | log_buffer info
		fi
		(
			local LINENO=0
			while IFS= read -r line
			do
				local LINE=$((LINE+1))
				case ${LINE} in
					1) local LOG_TYPE=cmd ;;
					*) local LOG_TYPE='>' ;;
				esac
				echo "${line}" | log_buffer "${LOG_TYPE}"
			done <<< "${RUNCMD_SUDO:+[${RUNCMD_SUDO}] }${CMDLINE}"
		)
		case "${RUNCMD_SUDO}" in
		"sudo/bash") 
			sudo bash -c "${CMDLINE}" 2> >(log_buffer error) > >(log_buffer)
			local STATUS=${PIPESTATUS[0]}
			;;
		*)	eval "${RUNCMD_SUDO:+${RUNCMD_SUDO} }${CMDLINE}" 2> >(log_buffer error) > >(log_buffer)
			local STATUS=${PIPESTATUS[0]}
			;;
		esac
	done
	trap - ERR
	trap - SIGINT
	return ${STATUS}
}

export -f run_cmd log_buffer

tab () {
	echo -en '\t'
}

is_core_functions () {
	return 0
}
