#!/bin/bash

check_core_functions () {
	is_core_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Core functions not loaded"
		exit 1
	fi
}

download_uncompress () {
	## check_download <URLs> <destination>
	## STRIPCOMPONENTS=<num>: Add strip --strip-components=<n> to tar command
	## ARCHIVEDIRS=<str>: Specify what directories to extract
	## NODELETEDESTDIR=<num>: if 1 don't delete ${DEST_DIR}
	set -x
	local URL=${1}
	local URL_HASH=$(echo -n "${URL}" | md5sum -t | awk '{print $1}')
	local DEST_DIR=${2}
	local TARFLAGS="${STRIPCOMPONENTS:+--strip-components=${STRIPCOMPONENTS}}"
	local NODELETEDESTDIR=${NODELETEDESTDIR:-0}
	local STATUS=0
	if [ ! -d ${DOWNLOAD_PATH} ]
	then
		mkdir -p ${DOWNLOAD_PATH}
	fi
	if [ -f "${DOWNLOAD_PATH}/url2file.map" ]
	then
		touch "${DOWNLOAD_PATH}/url2file.map"
	fi
	DOWNLOAD_FILE=$(grep ${URL_HASH} "${DOWNLOAD_PATH}/url2file.map" | awk '{print $2}')
	# if download file does not exists in database download package
	if [ -z ${DOWNLOAD_FILE} ]
	then
		local DOWNLOAD_FILE="$(basename $(curl -vLsI -o /dev/null "${URL}" 2>&1 | egrep -i '^< content-disposition:' | tr -d "\n\r" | sed -e 's/^.*filename="\?//;s/"\?$//'))"
		local STATUS=${?}	
		if [ -z ${DOWNLOAD_FILE} ]
		then
			local DOWNLOAD_FILE="$(basename ${URL})"
		fi
		echo "${URL_HASH} ${DOWNLOAD_FILE}" >> ${DOWNLOAD_PATH}/url2file.map
	fi
	if [ ! -f "${DOWNLOAD_PATH}/${DOWNLOAD_FILE}" ] && [ ${STATUS} -eq 0 ]
	then
		curl -LsR -o ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${URL} &&
		local STATUS=${?}
		if [ ${STATUS} -ne 0 ]
		then
			set +x
			return ${STATUS}
		fi
	fi
	if [ -d ${DEST_DIR} ] && [ ${NODELETEDESTDIR} -eq 0 ]
	then
		rm -rf ${DEST_DIR}
	fi
	local DOWNLOAD_FILE_TYPE=$(file -i ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} | awk '{print $2}' | sed 's/;$//' )
	mkdir -p ${DEST_DIR}
	case ${DOWNLOAD_FILE_TYPE} in
		application/x-xz|application/x-bzip2|application/gzip)	
			tar xf ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${TARFLAGS} -C ${DEST_DIR} ${ARCHIVE_DIRS}
			local STATUS=${?}
			;;
		*)
			cp ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${DEST_DIR}
			local STATUS=${?}
			;;
	esac
	set +x
	return ${STATUS}
}

BB_HOME=$(dirname $(realpath ${0}))
NPROCS=$(echo $(nproc)/2+1 | bc)

umask 0022

source ${BB_HOME}/bbxb.conf

# Check platform consistency
PLATFORM=${BB_HOME}/${PLATFORM_DIR:-platforms}/${PLATFORM_NAME}.conf
if [ -f ${PLATFORM} ]
then
	. ${PLATFORM}
	HARCH=${HM}-${HOS}-${HLIBC}
else
	echo "Platform file ${PLATFORM} does not exists!!! Proceeding as no platform specified."
	PLATFORM=native
	HARCH=$(gcc -dumpmachine)
	HMARCH=native
fi

DISTOS_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${DISTOS_DIR:-distos}
DOWNLOAD_PATH=${DATA_PATH}/${PRJ_NAME}/${DOWNLOAD_DIR:-downloads}
SRC_PATH=${DATA_PATH}/${PRJ_NAME}/${SRC_DIR:-sources}
BLD_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${BLD_DIR:-builds}
BIN_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${BIN_DIR:-binaries}
LOG_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${LOG_DIR:-logs}
STATUS_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${STATUS_DIR:-status}
TOOLCHAIN_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${TOOLCHAIN_DIR:-toolchain}
USERDATA_PATH=${DATA_PATH}/${PRJ_NAME}/${USERDATA_DIR:-data}

if [ ! -d ${LOG_PATH} ]
then
	mkdir -p ${LOG_PATH}
fi

export PATH=${TOOLCHAIN_PATH}/bin:${PATH}
export LD_LIBRARY_PATH=${TOOLCHAIN_PATH}/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}

PRJ_PATH=${BB_HOME}/${PRJ_DIR:-projects}
PKG_PATH=${BB_HOME}/${PKG_DIR:-packages}
PATCH_PATH=${BB_HOME}/${PATCH_DIR:-patches}
IMG_PATH=${BB_HOME}/${IMG_DIR:-images}

# Check the toolchains
gcc -v > /dev/null 2>&1
if [ ! ${?} -eq 0 ]
then
	echo "The toolchain for host compile does not exist."
	exit 1
fi
BARCH=$(gcc -dumpmachine)
${HARCH}-gcc -v > /dev/null 2>&1
if [ ! ${?} -eq 0 ]
then
	echo "The toolchain for cross-compile does not exist."
	exit 1
fi

is_core_functions () {
	return 0
}
