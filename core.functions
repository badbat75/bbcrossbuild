#!/bin/bash

check_core_functions () {
	is_core_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Core functions not loaded"
		exit 1
	fi
}

download_uncompress () {
	## check_download <URLs> <destination>
	## STRIPCOMPONENTS=<num>: Add strip --strip-components=<n> to tar command
	## ARCHIVEDIRS=<str>: Specify what directories to extract
	## NODELETEDESTDIR=<num>: if 1 don't delete ${DEST_DIR}
	set -x
	local URL=${1}
	local URL_HASH=$(echo -n "${URL}" | md5sum -t | awk '{print $1}')
	local DEST_DIR=${2}
	local STRIPCOMPONENTS=${STRIPCOMPONENTS:-1}
	local NODELETEDESTDIR=${NODELETEDESTDIR:-0}
	local STATUS=0
	if [ ${STRIPCOMPONENTS} -gt 0 ]
	then
		local TARFLAGS="--strip-components=${STRIPCOMPONENTS}"
	fi
	if [ ! -d ${DOWNLOAD_PATH} ]
	then
		mkdir -p ${DOWNLOAD_PATH}
	fi
	if [ -f "${DOWNLOAD_PATH}/url2file.map" ]
	then
		touch "${DOWNLOAD_PATH}/url2file.map"
	fi
	DOWNLOAD_FILE=$(grep ${URL_HASH} "${DOWNLOAD_PATH}/url2file.map" | awk '{print $2}')
	# if download file does not exists in database download package
	if [ -z ${DOWNLOAD_FILE} ]
	then
		local DOWNLOAD_FILE="$(curl -vLsI -o /dev/null "${URL}" 2>&1 | egrep -i '^< content-disposition:' | tr -d "\n\r" | sed -e 's/^.*filename="\?//;s/"\?$//')"
		local STATUS=${?}	
		if [ -z ${DOWNLOAD_FILE} ]
		then
			local DOWNLOAD_FILE="$(basename ${URL})"
		else
			local DOWNLOAD_FILE="$(basename ${DOWNLOAD_FILE})"
		fi
		echo "${URL_HASH} ${DOWNLOAD_FILE}" >> ${DOWNLOAD_PATH}/url2file.map
	fi
	if [ ! -f "${DOWNLOAD_PATH}/${DOWNLOAD_FILE}" ] && [ ${STATUS} -eq 0 ]
	then
		curl -LsR -o ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${URL} &&
		local STATUS=${?}
		if [ ${STATUS} -ne 0 ]
		then
			set +x
			return ${STATUS}
		fi
	fi
	if [ -d ${DEST_DIR} ] && [ ${NODELETEDESTDIR} -eq 0 ]
	then
		rm -rf ${DEST_DIR}
	fi
	local DOWNLOAD_FILE_TYPE=$(file -i ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} | awk '{print $2}' | sed 's/;$//' )
	mkdir -p ${DEST_DIR}
	case ${DOWNLOAD_FILE_TYPE} in
		application/x-xz|application/x-bzip2|application/gzip)	
			tar xf ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${TARFLAGS} -C ${DEST_DIR} ${ARCHIVE_DIRS}
			local STATUS=${?}
			;;
		*)
			cp ${DOWNLOAD_PATH}/${DOWNLOAD_FILE} ${DEST_DIR}
			local STATUS=${?}
			;;
	esac
	set +x
	return ${STATUS}
}

test_version () {
	test -z ${3} && echo "I need 2 arguments to compare and an operator." && return 255

	local SORTED="$(echo -e "${1}\n${3}" | sort -Vru -)"
	local BIGGEST="$(echo -e "${SORTED}" | head -n1)"
	local NO=$(echo -e "${SORTED}" | wc -l)

	case ${2} in
		-gt)
			if [ "${BIGGEST}" == "${1}" ] && [ ${NO} -gt 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-ge)
			if [ "${BIGGEST}" == "${1}" ]
			then
					return 0
			else
					return 1
			fi
		;;
		-lt)
			if [ "${BIGGEST}" != "${1}" ] && [ ${NO} -gt 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-le)
			if [ "${BIGGEST}" != "${1}" ] || [ ${NO} -eq 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-eq)
			if [ ${NO} -eq 1 ]
			then
					return 0
			else
					return 1
			fi
		;;
		-ne)
			if [ ${NO} -eq 2 ]
			then
					return 0
			else
					return 1
			fi
		;;
		*)
			echo "No valid operator specified!"
			return 255
		;;
	esac	
}

BB_HOME=$(dirname $(realpath ${0}))
NPROCS=$(echo $(nproc)/2+1 | bc)

umask 0022

source ${BB_HOME}/bbxb.conf

# Check platform consistency
PLATFORM=${BB_HOME}/${PLATFORM_DIR:-platforms}/${PLATFORM_NAME}.conf
if [ -f ${PLATFORM} ]
then
	. ${PLATFORM}
	HARCH=${HM}-${HOS}-${HLIBC}
else
	echo "Platform file ${PLATFORM} does not exists!!! Proceeding as no platform specified."
	PLATFORM=native
	HARCH=$(${TOOLCHAIN_CC} -dumpmachine)
	HMARCH=native
fi

GLOBAL_SRC_PATH=${DATA_PATH}/${SRC_DIR:-sources}
GLOBAL_BLD_PATH=${DATA_PATH}/${BLD_DIR:-builds}
GLOBAL_LOG_PATH=${DATA_PATH}/${LOG_DIR:-logs}
GLOBAL_TOOLCHAIN_PATH=${DATA_PATH}/${TOOLCHAIN_DIR:-toolchain}
DOWNLOAD_PATH=${DATA_PATH}/${DOWNLOAD_DIR:-downloads}

if [ ! -d ${GLOBAL_LOG_PATH} ]
then
	mkdir -p ${GLOBAL_LOG_PATH}
fi

DISTOS_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${DISTOS_DIR:-distos}
SRC_PATH=${DATA_PATH}/${PRJ_NAME}/${SRC_DIR:-sources}
BLD_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${BLD_DIR:-builds}
BIN_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${BIN_DIR:-binaries}
LOG_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${LOG_DIR:-logs}
STATUS_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${STATUS_DIR:-status}
TOOLCHAIN_PATH=${DATA_PATH}/${PRJ_NAME}/${PLATFORM_NAME}/${TOOLCHAIN_DIR:-toolchain}
USERDATA_PATH=${DATA_PATH}/${PRJ_NAME}/${USERDATA_DIR:-data}

if [ ! -d ${LOG_PATH} ]
then
	mkdir -p ${LOG_PATH}
fi

export PATH=${GLOBAL_TOOLCHAIN_PATH}/bin:${TOOLCHAIN_PATH}/bin:${PATH}
export LD_LIBRARY_PATH=${TOOLCHAIN_PATH}/lib${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}

PRJ_PATH=${BB_HOME}/${PRJ_DIR:-projects}
PKG_PATH=${BB_HOME}/${PKG_DIR:-packages}
PATCH_PATH=${BB_HOME}/${PATCH_DIR:-patches}
IMG_PATH=${BB_HOME}/${IMG_DIR:-images}

is_core_functions () {
	return 0
}
