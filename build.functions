#!/bin/bash

check_core_functions

function check_build_functions () {
	is_core_functions 2>/dev/null
	if [ ! ${?} ]
	then
		echo "Core functions not loaded"
		exit 1
	fi
}

function setbuildenv () {
	OPTS="" OPTS_WITH_VALUE="--target" param2value "${@}"
	local TARGET_ENV=${_param_target:-target}
	case ${TARGET_ENV} in
		native)
			unset QEMU_LD_PREFIX COMMON_CPPFLAGS SYSROOT_GCCVER QEMU_LD_LIBRARY_PATH
			PLATFORM_CFLAGS="-march=native"
			PLATFORM_RUSTFLAGS="-C target-cpu=native"
			COMMON_CFLAGS="-I${GLOBAL_TOOLCHAIN_PATH}/include"
			COMMON_CXXFLAGS="${COMMON_CFLAGS}"
			COMMON_FCFLAGS="${COMMON_CFLAGS}"
			COMMON_LDFLAGS="-L${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -Wl,-rpath -Wl,${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -Wl,-rpath-link -Wl,${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_PKG_CONFIG_LIBDIR="${GLOBAL_TOOLCHAIN_PATH}/lib/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${GLOBAL_TOOLCHAIN_PATH}/share/pkgconfig"
		;;
		cross)
			unset QEMU_LD_PREFIX COMMON_CPPFLAGS SYSROOT_GCCVER QEMU_LD_LIBRARY_PATH
			PLATFORM_CFLAGS="-march=native"
			PLATFORM_RUSTFLAGS="-C target-cpu=native"
			COMMON_CFLAGS+=" -I${TOOLCHAIN_PATH}/include"
			COMMON_CFLAGS="-I${GLOBAL_TOOLCHAIN_PATH}/include"
			COMMON_CXXFLAGS="${COMMON_CFLAGS}"
			COMMON_FCFLAGS="${COMMON_CFLAGS}"
			COMMON_LDFLAGS="-L${TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -L${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -Wl,-rpath -Wl,${TOOLCHAIN_PATH}/lib:${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -Wl,-rpath-link -Wl,${TOOLCHAIN_PATH}/lib"
			COMMON_LDFLAGS+=" -Wl,-rpath-link -Wl,${GLOBAL_TOOLCHAIN_PATH}/lib"
			COMMON_PKG_CONFIG_LIBDIR="${GLOBAL_TOOLCHAIN_PATH}/lib/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${GLOBAL_TOOLCHAIN_PATH}/share/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${TOOLCHAIN_PATH}/lib/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${TOOLCHAIN_PATH}/share/pkgconfig"
		;;
		target)
			if [ ${HARCH} != ${BARCH} ]
			then
				export CROSS_COMPILING=yes
				export PKG_CONFIG_ALLOW_CROSS=1
			fi
			export QEMU_LD_PREFIX="${BIN_PATH}"
			#PLATFORM_CFLAGS="${HMARCH:+-march=${HMARCH}}${HMCPU:+ -mtune=${HMCPU}}${HMFPU:+ -mfpu=${HMFPU}}${HMFLOATABI:+ -mfloat-abi=${HMFLOATABI}}${HMGCCPARAMS:+ ${HMGCCPARAMS}}"
			#PLATFORM_RUSTFLAGS="${HMCPU:+-C target-cpu=${HMCPU}}${HMARCH_RUST:+ -C target-feature=${HMARCH_RUST} }"

			COMMON_CFLAGS="-I${BIN_PATH}${TARGET_INCLUDEDIR}"
			COMMON_CXXFLAGS="-I${BIN_PATH}${TARGET_INCLUDEDIR}"
			COMMON_FCFLAGS="-I${BIN_PATH}${TARGET_INCLUDEDIR}"
			COMMON_CPPFLAGS="-I${BIN_PATH}${TARGET_INCLUDEDIR}"
			COMMON_LDFLAGS="-Wl,-rpath-link,${BIN_PATH}/lib${TARGET_LIBSUFFIX} -L${BIN_PATH}/lib${TARGET_LIBSUFFIX}"
			COMMON_LDFLAGS+=" -Wl,-rpath-link,${BIN_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX} -L${BIN_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX}"
			COMMON_PKG_CONFIG_LIBDIR="${BIN_PATH}/lib${TARGET_LIBSUFFIX}/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${BIN_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX}/pkgconfig"
			COMMON_PKG_CONFIG_LIBDIR+=":${BIN_PATH}${TARGET_PREFIX}/share/pkgconfig"
			COMMON_PKG_CONFIG_SYSROOT="${BIN_PATH}"
			unset SYSROOT_GCCVER QEMU_LD_LIBRARY_PATH
			# Construct build tools flags
			# Build Include search paths
			if [ -d ${DISTOS_PATH}${TARGET_INCLUDEDIR} ]
			then
				SYSROOT_GCCVER="$(find ${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/ -mindepth 1 -maxdepth 1 -type d -printf '%P\n' | sort -hr | head -n1)"
				SYSROOT="${DISTOS_PATH}"
				COMMON_CFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR} ${STD_CFLAGS} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}${TARGET_LIBSUFFIX}"
				COMMON_CXXFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR} ${STD_CXXFLAGS} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}${TARGET_LIBSUFFIX}"
				COMMON_FCFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR} ${STD_CXXFLAGS} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}${TARGET_LIBSUFFIX}"
				COMMON_CPPFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR} ${STD_CPPFLAGS} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}${TARGET_LIBSUFFIX}"
				COMMON_LDFLAGS+=" -Wl,-rpath-link,${DISTOS_PATH}/lib${TARGET_LIBSUFFIX} -L${DISTOS_PATH}/lib${TARGET_LIBSUFFIX}"
				COMMON_LDFLAGS+=" -Wl,-rpath-link,${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX} -L${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX}"
				COMMON_PKG_CONFIG_LIBDIR+=":${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX}/pkgconfig"
				COMMON_PKG_CONFIG_LIBDIR+=":${DISTOS_PATH}/usr/share/pkgconfig"
				COMMON_PKG_CONFIG_SYSROOT="${DISTOS_PATH}"
				# Try to find if gcc libraries are installed and not yet defined in binary dir, if so set search path on that path
				if [ "$(gcc_sysroot)" == "${DISTOS_PATH}" ]
				then
					if [ -n "${SYSROOT_GCCVER}" ]
					then
						COMMON_CXXFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR}/c++/${SYSROOT_GCCVER} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}/${HARCH}/c++/${SYSROOT_GCCVER}"
						COMMON_CPPFLAGS+=" -I${DISTOS_PATH}${TARGET_INCLUDEDIR}/c++/${SYSROOT_GCCVER} -I${DISTOS_PATH}${TARGET_INCLUDEDIR}/${HARCH}/c++/${SYSROOT_GCCVER}"
						COMMON_LDFLAGS+=" -Wl,-rpath-link,${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/${SYSROOT_GCCVER} -L${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/${SYSROOT_GCCVER}"
						#echo "TOOLCHAIN: ${TOOLCHAIN}"
						#echo "PKG_TOOLCHAIN: ${PKG_TOOLCHAIN}"
						case ${PKG_TOOLCHAIN:-${TOOLCHAIN}} in
							gnu)
								COMMON_CFLAGS+=" -B${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX} -B${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/${SYSROOT_GCCVER}"
								COMMON_CXXFLAGS+=" -B${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX} -B${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/${SYSROOT_GCCVER}"
								COMMON_LDFLAGS+=" -B${DISTOS_PATH}${TARGET_LIBDIR}${TARGET_LIBSUFFIX} -B${DISTOS_PATH}${TARGET_LIBDIR}/gcc/${HARCH}/${SYSROOT_GCCVER}"
								;;
						esac			
					fi
				else
				SYSROOT_GCCVER=$(${TOOLCHAIN_PATH}/bin/${HARCH}-gcc -dumpversion 2>/dev/null)
				fi
			else
				SYSROOT="${BIN_PATH}"
				if ${TOOLCHAIN_PATH}/bin/${HARCH}-gcc -dumpversion >/dev/null 2>&1
				then
					SYSROOT_GCCVER=$(${TOOLCHAIN_PATH}/bin/${HARCH}-gcc -dumpversion 2>/dev/null)
					if [ -d "$(gcc_toolchain_print_searchdirs)" ]
					then
						QEMU_LD_LIBRARY_PATH="$(gcc_toolchain_print_searchdirs):"
					fi
					### Search path in the toolchain gcc libs
					# -enable-version-specific-runtime-libs workaround to fing libgcc_s under lib64 path instead of ${GCC_VER}
					local GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE="$(realpath -m $(gcc_toolchain_print_searchdirs)/../lib64)"
					#if [ -n "${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}" ] && [ -d "${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}" ]
					#then
					#	QEMU_LD_LIBRARY_PATH+="${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}:"
					#fi			
					case ${PKG_TOOLCHAIN:-${TOOLCHAIN}} in
						gnu) if [ -n "${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}" ] && [ -d "${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}" ]
							then
								COMMON_LDFLAGS+=" -L${GCC_SPECIFIC_RUN_TIME_LIBS_ISSUE}"
							fi
						;;
						llvm) #COMMON_CFLAGS+=" $(gcc_toolchain_libraries_compilerflags)"
							#COMMON_CXXFLAGS+=" $(gcc_toolchain_libraries_compilerflags)"
							COMMON_LDFLAGS+=" $(gcc_toolchain_libraries_linkerflags)"
						;;
					esac
				fi
			fi
			QEMU_LD_LIBRARY_PATH+=${SYSROOT}${TARGET_LIBDIR}${TARGET_LIBSUFFIX}
			case ${PKG_TOOLCHAIN:-${TOOLCHAIN}} in
				gnu)
				;;
			esac
			SYSROOT_FLAGS="--sysroot=${SYSROOT}"
		;;
		*) echo "${TARGET_ENV} not supported!!!"; return 1;;
	esac
}

function setllvmpollyenv () {
	unset LLVM_EXTRAPOLLYFLAGS
	unset LLVM_KERNELPOLLYFLAGS
	unset LLVM_EXTRAPOLLYFLAGSLIBS
	unset LLVM_KERNELPOLLYFLAGSLIBS

	local OPTIONS="${@}"

	local LIBCLANG_RTBUILTINS="${TOOLCHAIN_PATH}/lib/clang/${LLVM_VER}/lib/${HOS}/libclang_rt.builtins-${LLVM_ARCH}.a"
	#if [ ! -z "${OPTIONS}" ] && [ -f ${LIBCLANG_RTBUILTINS} ]

	case x${HMARCH} in
		xarmv*)
				if [[ "${HMARCH}" < "armv7" && "${HMARCH}" != "armv6m" ]]
				then
					unset OPTIONS
				fi
			;;
	esac

	case x${HM} in
		xarm)
			if [ "${HMFLOATABI}" == "hard" ]
			then
				local LLVM_ARCH=armhf
			else
				local LLVM_ARCH=arm
			fi
			;;
		*) local LLVM_ARCH=${HM}
			;;
	esac

	if [ ! -z "${OPTIONS}" ]
	then
		LLVM_EXTRAPOLLYFLAGS="-mllvm -polly"
		#### Missing _mulodi4 symbol, skip polly build for kernel 
		case ${HM} in
			arm)
				# Need to add static rtbuiltins libraries to arm link to avoid missing _mulodi4 symbol
				# but this is not supported in kernel building so we can't set polly for kernel build
				LLVM_EXTRAPOLLYFLAGSLIBS="-Wl,${TOOLCHAIN_PATH}/lib/clang/${LLVM_VER}/lib/${HOS}/libclang_rt.builtins-${LLVM_ARCH}.a"
				LLVM_KERNELPOLLYFLAGS=
				;;
			*)
				# Normal behaviour
				LLVM_KERNELPOLLYFLAGS="-mllvm -polly"
				;;
		esac

		if [ "$( echo ${OPTIONS} | grep -o "all" )" == "all" ]
		then
			local OPTIONS="polly vectorizer parallel"
		fi 
		
		for option in ${OPTIONS}
		do
			case ${option} in
				polly)
					;;
				vectorizer)
					LLVM_EXTRAPOLLYFLAGS+=" -mllvm -polly-vectorizer=stripmine"
					if [ "${HM}" != "arm" ]
					then
						LLVM_KERNELPOLLYFLAGS+=" -mllvm -polly-vectorizer=stripmine"
					fi
					;;
				parallel)
					# polly-parallel not supported in kernel build because libgomp cannot be statically linked to kernel
					LLVM_EXTRAPOLLYFLAGS+=" -mllvm -polly-parallel"
					;;
				*)
					echo "Error: ${option} not recognized"
					return 1
					;;
			esac
		done
	fi
}

function settcenv () {
	unset TOOLCHAIN_CC \
		TOOLCHAIN_CXX \
		TOOLCHAIN_CPP \
		TOOLCHAIN_FC \
		TOOLCHAIN_F90 \
		TOOLCHAIN_AR \
		TOOLCHAIN_AS \
		TOOLCHAIN_NM \
		TOOLCHAIN_RANLIB \
		TOOLCHAIN_STRIP \
		TOOLCHAIN_OBJCOPY \
		TOOLCHAIN_OBJDUMP \
		TOOLCHAIN_READELF \
		TOOLCHAIN_LINKER \
		TOOLCHAIN_LD \
		TOOLCHAIN_CC_FOR_BUILD \
		TOOLCHAIN_CXX_FOR_BUILD \
		TOOLCHAIN_CPP_FOR_BUILD \
		TOOLCHAIN_FC_FOR_BUILD \
		TOOLCHAIN_F90_FOR_BUILD \
		TOOLCHAIN_AR_FOR_BUILD \
		TOOLCHAIN_AS_FOR_BUILD \
		TOOLCHAIN_NM_FOR_BUILD \
		TOOLCHAIN_RANLIB_FOR_BUILD \
		TOOLCHAIN_STRIP_FOR_BUILD \
		TOOLCHAIN_OBJCOPY_FOR_BUILD \
		TOOLCHAIN_OBJDUMP_FOR_BUILD \
		TOOLCHAIN_READELF_FOR_BUILD \
		TOOLCHAIN_LINKER_FOR_BUILD \
		TOOLCHAIN_LD_FOR_BUILD \
		TOOLCHAIN_LINKERFLAGS \
		TOOLCHAIN_COMPFLAGS \
		TOOLCHAIN_EXTRA_C_CMD \
		OPTCOMP_FLAGS \
		OPTLINK_FLAGS

	OPTS="" OPTS_WITH_VALUE="--target" param2value "${@}"
	local TARGET_ENV=${_param_target:-target}
	setbuildenv --target ${TARGET_ENV}

	local TOOLCHAIN=${PKG_TOOLCHAIN:-${TOOLCHAIN}}
	echo Toolchain: ${TOOLCHAIN}
	if [ ${TOOLCHAIN} == llvm ]
	then
		if [ -z "${PKG_LLVMPOLLYFEATURES}" ]
		then
			setllvmpollyenv ${LLVM_POLLY_FEATURES}
		else
			eval "echo 'Override LLVM Polly features: ${PKG_LLVMPOLLYFEATURES}' >> ${LOG_FILE}"
			setllvmpollyenv ${PKG_LLVMPOLLYFEATURES}
		fi
	fi
	echo "Target Environment: ${TARGET_ENV}"
	case ${TOOLCHAIN} in
		gnu)
			TOOLCHAIN_CC_FOR_BUILD=$(which gcc)
			TOOLCHAIN_CPP_FOR_BUILD="$(which gcc) -E"
			if g++ --version > /dev/null 2>&1
			then
				TOOLCHAIN_CXX_FOR_BUILD=$(which g++)
				TOOLCHAIN_CXXCPP_FOR_BUILD="$(which g++) -E"
			fi
			if gfortran --version > /dev/null 2>&1
			then
				TOOLCHAIN_FC_FOR_BUILD=$(which gfortran)
				TOOLCHAIN_F90_FOR_BUILD=$(which gfortran)
			fi
			TOOLCHAIN_AR_FOR_BUILD=$(which gcc-ar)
			TOOLCHAIN_AS_FOR_BUILD=$(which as)
			TOOLCHAIN_NM_FOR_BUILD=$(which gcc-nm)
			TOOLCHAIN_RANLIB_FOR_BUILD=$(which gcc-ranlib)
			TOOLCHAIN_STRIP_FOR_BUILD=$(which strip)
			TOOLCHAIN_OBJCOPY_FOR_BUILD=$(which objcopy)
			TOOLCHAIN_OBJDUMP_FOR_BUILD=$(which objdump)
			TOOLCHAIN_READELF_FOR_BUILD=$(which readelf)
			TOOLCHAIN_LINKER_FOR_BUILD=${PKG_OVERRIDELD:-${GCC_DEFAULT_LD:-gold}}
			TOOLCHAIN_LINKER_EXE_FOR_BUILD=$(which ld.${TOOLCHAIN_LINKER_FOR_BUILD})
			TOOLCHAIN_LINKERFLAGS_FOR_BUILD="-fuse-ld=${TOOLCHAIN_LINKER_FOR_BUILD}"

			case ${PKG_OVERRIDELTO:-${LTOENABLE:-0}} in
				1|2|fat|thin)
					OPTCOMP_FLAGS+=" -flto=${LTOPROCS}"
					OPTLINK_FLAGS+=" -fuse-linker-plugin"
					;;
			esac

			case ${TARGET_ENV} in
				native|cross)
					TOOLCHAIN_CC=${TOOLCHAIN_CC_FOR_BUILD}
					TOOLCHAIN_CPP=${TOOLCHAIN_CPP_FOR_BUILD}
					TOOLCHAIN_CXX=${TOOLCHAIN_CXX_FOR_BUILD}
					if flang --version > /dev/null 2>&1
					then
						TOOLCHAIN_FC=${TOOLCHAIN_FC_FOR_BUILD}
						TOOLCHAIN_F90=${TOOLCHAIN_F90_FOR_BUILD}
					fi
					TOOLCHAIN_AR=${TOOLCHAIN_AR_FOR_BUILD}
					TOOLCHAIN_AS=${TOOLCHAIN_AS_FOR_BUILD}
					TOOLCHAIN_NM=${TOOLCHAIN_NM_FOR_BUILD}
					TOOLCHAIN_RANLIB=${TOOLCHAIN_RANLIB_FOR_BUILD}
					TOOLCHAIN_STRIP=${TOOLCHAIN_STRIP_FOR_BUILD}
					TOOLCHAIN_OBJCOPY=${TOOLCHAIN_OBJCOPY_FOR_BUILD}
					TOOLCHAIN_OBJDUMP=${TOOLCHAIN_OBJDUMP_FOR_BUILD}
					TOOLCHAIN_READELF=${TOOLCHAIN_READELF_FOR_BUILD}
					TOOLCHAIN_LINKER=${TOOLCHAIN_LINKER_FOR_BUILD}
					TOOLCHAIN_LINKER_EXE=${TOOLCHAIN_LINKER_EXE_FOR_BUILD}
					TOOLCHAIN_COMPFLAGS="${GNU_EXTRAGCCFLAGS}"
					TOOLCHAIN_EXTRA_C_CMD=""
					TOOLCHAIN_LINKERFLAGS="-fuse-ld=${TOOLCHAIN_LINKER} ${GNU_EXTRALDFLAGS}"
				;;
				target)
					if ${HARCH}-gcc --version > /dev/null 2>&1
					then
						TOOLCHAIN_CC=$(which ${HARCH}-gcc)
						TOOLCHAIN_CPP="$(which ${HARCH}-gcc) -E"
						if ${HARCH}-g++ --version > /dev/null 2>&1
						then
							TOOLCHAIN_CXX=$(which ${HARCH}-g++)
						fi
						if ${HARCH}-gfortran --version > /dev/null 2>&1
						then
							TOOLCHAIN_FC=$(which ${HARCH}-gfortran)
							TOOLCHAIN_F90=$(which ${HARCH}-gfortran)
						fi
						TOOLCHAIN_AR=$(which ${HARCH}-gcc-ar)
						TOOLCHAIN_AS=$(which ${HARCH}-as)
						TOOLCHAIN_NM=$(which ${HARCH}-gcc-nm)
						TOOLCHAIN_RANLIB=$(which ${HARCH}-gcc-ranlib)
						TOOLCHAIN_STRIP=$(which ${HARCH}-strip)
						TOOLCHAIN_OBJCOPY=$(which ${HARCH}-objcopy)
						TOOLCHAIN_OBJDUMP=$(which ${HARCH}-objdump)
						TOOLCHAIN_READELF=$(which ${HARCH}-readelf)
						TOOLCHAIN_LINKER=${PKG_OVERRIDELD:-${GCC_DEFAULT_LD:-gold}}
						TOOLCHAIN_LINKER_EXE=$(which ${HARCH}-ld.${TOOLCHAIN_LINKER})
					fi
					if [ ${PKG_FAULTYCFLAGS:-0} -eq 1 ]
					then
						TOOLCHAIN_COMPFLAGS="${GNU_EXTRAGCCFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD="${SYSROOT_FLAGS}"
				
					else
						TOOLCHAIN_COMPFLAGS="${SYSROOT_FLAGS} ${GNU_EXTRAGCCFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD=""
					fi
					TOOLCHAIN_LINKERFLAGS="${SYSROOT_FLAGS} -fuse-ld=${TOOLCHAIN_LINKER} ${GNU_EXTRALDFLAGS}"
				;;
			esac
			;;
		llvm)
			TOOLCHAIN_CC_FOR_BUILD=$(which clang)
			TOOLCHAIN_CXX_FOR_BUILD=$(which clang++)
			TOOLCHAIN_CPP_FOR_BUILD="$(which clang) -E"
			if flang --version > /dev/null 2>&1
			then
				TOOLCHAIN_FC_FOR_BUILD=$(which flang)
				TOOLCHAIN_F90_FOR_BUILD=$(which flang)
			fi
			TOOLCHAIN_AR_FOR_BUILD=$(which llvm-ar)
			TOOLCHAIN_AS_FOR_BUILD=$(which llvm-as)
			TOOLCHAIN_NM_FOR_BUILD=$(which llvm-nm)
			TOOLCHAIN_RANLIB_FOR_BUILD=$(which llvm-ranlib)
			TOOLCHAIN_STRIP_FOR_BUILD=$(which llvm-strip)
			TOOLCHAIN_OBJCOPY_FOR_BUILD=$(which llvm-objcopy)
			TOOLCHAIN_OBJDUMP_FOR_BUILD=$(which llvm-objdump)
			TOOLCHAIN_READELF_FOR_BUILD=$(which llvm-readelf)
			TOOLCHAIN_LINKER_FOR_BUILD=${PKG_OVERRIDELD:-${LLVM_DEFAULT_LD:-lld}}
			TOOLCHAIN_LINKER_EXE_FOR_BUILD=$(which ld.${TOOLCHAIN_LINKER})
			TOOLCHAIN_LINKERFLAGS_FOR_BUILD="-fuse-ld=${TOOLCHAIN_LINKER} -Wl,--threads=${NPROCS}"
			case ${PKG_OVERRIDELTO:-${LTOENABLE:-0}} in
				1|fat)
					TOOLCHAIN_COMPFLAGS+=" -flto=full"
					;;
				2|thin)
					TOOLCHAIN_COMPFLAGS+=" -flto=thin"
					;;
			esac

			case ${TARGET_ENV} in
				native|cross)
					TOOLCHAIN_CC=${TOOLCHAIN_CC_FOR_BUILD}
					TOOLCHAIN_CPP=${TOOLCHAIN_CPP_FOR_BUILD}
					TOOLCHAIN_CXX=${TOOLCHAIN_CXX_FOR_BUILD}
					if flang --version > /dev/null 2>&1
					then
						TOOLCHAIN_FC=${TOOLCHAIN_FC_FOR_BUILD}
						TOOLCHAIN_F90=${TOOLCHAIN_F90_FOR_BUILD}
					fi
					TOOLCHAIN_AR=${TOOLCHAIN_AR_FOR_BUILD}
					TOOLCHAIN_AS=${TOOLCHAIN_AS_FOR_BUILD}
					TOOLCHAIN_NM=${TOOLCHAIN_NM_FOR_BUILD}
					TOOLCHAIN_RANLIB=${TOOLCHAIN_RANLIB_FOR_BUILD}
					TOOLCHAIN_STRIP=${TOOLCHAIN_STRIP_FOR_BUILD}
					TOOLCHAIN_OBJCOPY=${TOOLCHAIN_OBJCOPY_FOR_BUILD}
					TOOLCHAIN_OBJDUMP=${TOOLCHAIN_OBJDUMP_FOR_BUILD}
					TOOLCHAIN_READELF=${TOOLCHAIN_READELF_FOR_BUILD}
					TOOLCHAIN_LINKER=${TOOLCHAIN_LINKER_FOR_BUILD}
					TOOLCHAIN_LINKER_EXE=${TOOLCHAIN_LINKER_EXE_FOR_BUILD}
					if [ ${PKG_FAULTYCFLAGS:-0} -eq 1 ]
					then
						TOOLCHAIN_COMPFLAGS="${LLVM_EXTRACLANGFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD="${LLVM_EXTRAPOLLYFLAGS}"
					else
						TOOLCHAIN_COMPFLAGS="${LLVM_EXTRACLANGFLAGS} ${LLVM_EXTRAPOLLYFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD=""
					fi
					TOOLCHAIN_LINKERFLAGS="-fuse-ld=${TOOLCHAIN_LINKER} -Wl,--threads=${NPROCS} ${LLVM_EXTRALDFLAGS} ${LLVM_EXTRAPOLLYFLAGSLIBS}"
				;;
				target)
					TOOLCHAIN_CC=$(which clang)
					TOOLCHAIN_CPP="$(which clang) -E"
					TOOLCHAIN_CXX=$(which clang++)
					if flang --version > /dev/null 2>&1
					then
						TOOLCHAIN_FC=$(which flang)
						TOOLCHAIN_F90=$(which flang)
					fi
					TOOLCHAIN_AR=$(which llvm-ar)
					TOOLCHAIN_AS=$(which llvm-as)
					TOOLCHAIN_NM=$(which llvm-nm)
					TOOLCHAIN_RANLIB=$(which llvm-ranlib)
					TOOLCHAIN_STRIP=$(which llvm-strip)
					TOOLCHAIN_OBJCOPY=$(which llvm-objcopy)
					TOOLCHAIN_OBJDUMP=$(which llvm-objdump)
					TOOLCHAIN_READELF=$(which llvm-readelf)
					TOOLCHAIN_LINKER=${PKG_OVERRIDELD:-${LLVM_DEFAULT_LD:-lld}}
					TOOLCHAIN_LINKER_EXE=$(which ld.${TOOLCHAIN_LINKER})
					if [ ${PKG_FAULTYCFLAGS:-0} -eq 1 ]
					then
						TOOLCHAIN_COMPFLAGS="${LLVM_EXTRACLANGFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD="--target=${HARCH} ${SYSROOT_FLAGS} ${LLVM_EXTRAPOLLYFLAGS}"
					else
						TOOLCHAIN_COMPFLAGS="${SYSROOT_FLAGS} ${LLVM_EXTRACLANGFLAGS} ${LLVM_EXTRAPOLLYFLAGS}"
						TOOLCHAIN_EXTRA_C_CMD="--target=${HARCH}"
					fi
					TOOLCHAIN_LINKERFLAGS="${SYSROOT_FLAGS} -fuse-ld=${TOOLCHAIN_LINKER} -Wl,--threads=${NPROCS} ${LLVM_EXTRALDFLAGS} ${LLVM_EXTRAPOLLYFLAGSLIBS}"
				;;
			esac
			;;
	esac
	case ${TOOLCHAIN_LINKER} in
		gold)
			TOOLCHAIN_LINKERFLAGS+=" -Wl,--threads -Wl,--thread-count,${NPROCS}"
			TOOLCHAIN_LINKERFLAGS_FOR_BUILD+=" -Wl,--threads -Wl,--thread-count,${NPROCS}"
			;;
		lld)
			TOOLCHAIN_LINKERFLAGS+=" -Wl,--thinlto-jobs=${NPROCS}"
			TOOLCHAIN_LINKERFLAGS_FOR_BUILD+=" -Wl,--thinlto-jobs=${NPROCS}"
			;;
	esac
			
	if [ ${PKG_DEBUG:-${DEBUG:-0}} -eq 1 ]
	then
		OPTLEVEL=2
		OPTCOMP_FLAGS+="-g"
	fi
	
	OPTCOMP_FLAGS+="${OPTLEVEL:+ -O${OPTLEVEL}}"
}

function create_environment_source () {
	### Munge environment variables depending on target build:
	### --target {native|cross|target}
	###		native:	Build Arch_A = Host Arch_A = Target Arch_A - Installed in Global Toolchain
	###		cross:	Build Arch_A = Host Arch_A / Target Arch_B - Installed in Project Toolchain
	###		target:	Build Arch_A / Host Arch_B = Target Arch_B - Installed in SYSROOT (Default)
	OPTS="" OPTS_WITH_VALUE="--target" param2value "${@}"
	local TARGET_ENV=${_param_target:-target}
	settcenv --target ${TARGET_ENV}
	cat <<-EOF > environment.source
		#################################################################################
		###### ${PKG_NAME}
		### Source file with all the environment specified
		### Tool chain: ${PKG_TOOLCHAIN:-${TOOLCHAIN}}
		### C Wrapper: ${CCWRAPPER}
		### Build type: ${BUILD_PROCESS}
		### Target: ${TARGET_ENV} [${_param_target}]
		###### Other environment variables:
		### DISTOS_PATH=${DISTOS_PATH}
		### BIN_PATH=${BIN_PATH}
		### PKG_SRCDIR=${PKG_SRCDIR}
		### PKG_BLDDIR=${PKG_BLDDIR}
		#################################################################################

		export SYSROOT='${SYSROOT}'
		export CC_FOR_BUILD='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CC_FOR_BUILD}'
		export CFLAGS_FOR_BUILD='-march=native${OPTCOMP_FLAGS}'
		export CPP_FOR_BUILD='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CPP_FOR_BUILD}'
		export CPPFLAGS_FOR_BUILD='-march=native${OPTCOMP_FLAGS}'
	EOF
	if [ ! -z "${TOOLCHAIN_CXX_FOR_BUILD}" ]
	then
		cat <<-EOF >> environment.source
			export CXX_FOR_BUILD='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CXX_FOR_BUILD}'
			export CXXFLAGS_FOR_BUILD='-march=native${OPTCOMP_FLAGS}'
		EOF
	fi
	if [ ! -z "${TOOLCHAIN_FC_FOR_BUILD}" ]
	then
		cat <<-EOF >> environment.source
			export FC_FOR_BUILD='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_FC_FOR_BUILD}'
			export FFLAGS_FOR_BUILD='-march=native${OPTCOMP_FLAGS}'
			export F90_FOR_BUILD='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_F90_FOR_BUILD}'
			export F90FLAGS_FOR_BUILD='-march=native${OPTCOMP_FLAGS}'
		EOF
	fi
	cat <<-EOF >> environment.source
		export LINKER_EXE_FOR_BUILD='${TOOLCHAIN_LINKER_EXE_FOR_BUILD}'
		export LDFLAGS_FOR_BUILD='${TOOLCHAIN_LINKERFLAGS_FOR_BUILD}'
		export AR_FOR_BUILD='${TOOLCHAIN_AR_FOR_BUILD}'
		export AS_FOR_BUILD='${TOOLCHAIN_AS_FOR_BUILD}'
		export NM_FOR_BUILD='${TOOLCHAIN_NM_FOR_BUILD}'
		export RANLIB_FOR_BUILD='${TOOLCHAIN_RANLIB_FOR_BUILD}'
		export STRIP_FOR_BUILD='${TOOLCHAIN_STRIP_FOR_BUILD}'
		export OBJCOPY_FOR_BUILD='${TOOLCHAIN_OBJCOPY_FOR_BUILD}'
		export OBJDUMP_FOR_BUILD='${TOOLCHAIN_OBJDUMP_FOR_BUILD}'
		export READELF_FOR_BUILD='${TOOLCHAIN_READELF_FOR_BUILD}'

	EOF
	if [ ! -z "${TOOLCHAIN_CC}" ]
	then
		cat <<-EOF >> environment.source
		export CC='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CC}${TOOLCHAIN_EXTRA_C_CMD:+ ${TOOLCHAIN_EXTRA_C_CMD}}'
		export CFLAGS='${TOOLCHAIN_COMPFLAGS} ${COMMON_CFLAGS} ${PLATFORM_CFLAGS} ${OPTCOMP_FLAGS} ${PKG_CFLAGS}'
		export CPP='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CPP}${TOOLCHAIN_EXTRA_C_CMD:+ ${TOOLCHAIN_EXTRA_C_CMD}}'
		export CPPFLAGS='${TOOLCHAIN_COMPFLAGS} ${COMMON_CPPFLAGS} ${PLATFORM_CFLAGS} ${PKG_CPPFLAGS}'
	EOF
	fi
	if [ ! -z "${TOOLCHAIN_CXX}" ]
	then
		cat <<-EOF >> environment.source
			export CXX='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_CXX}${TOOLCHAIN_EXTRA_C_CMD:+ ${TOOLCHAIN_EXTRA_C_CMD}}'
			export CXXFLAGS='${TOOLCHAIN_COMPFLAGS} ${COMMON_CXXFLAGS} ${PLATFORM_CFLAGS} ${OPTCOMP_FLAGS} ${PKG_CXXFLAGS}'
		EOF
	fi
	if [ ! -z "${TOOLCHAIN_FC}" ]
	then
		cat <<-EOF >> environment.source
			export FC='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_FC}${TOOLCHAIN_EXTRA_C_CMD:+ ${TOOLCHAIN_EXTRA_C_CMD}}'
			export FFLAGS='${TOOLCHAIN_COMPFLAGS} ${COMMON_FCFLAGS} ${PLATFORM_CFLAGS} ${OPTCOMP_FLAGS} ${PKG_FCFLAGS}'
			export F90='${CCWRAPPER:+${CCWRAPPER} }${TOOLCHAIN_F90}${TOOLCHAIN_EXTRA_C_CMD:+ ${TOOLCHAIN_EXTRA_C_CMD}}'
			export F90FLAGS='${TOOLCHAIN_COMPFLAGS} ${COMMON_FCFLAGS} ${PLATFORM_CFLAGS} ${OPTCOMP_FLAGS} ${PKG_FCFLAGS}'
		EOF
	fi
	cat <<-EOF >> environment.source
		export LINKER_EXE='${TOOLCHAIN_LINKER_EXE}'
		export LDFLAGS='${TOOLCHAIN_LINKERFLAGS} ${COMMON_LDFLAGS} ${OPTLINK_FLAGS} ${PKG_LDFLAGS}'

		export AR='${TOOLCHAIN_AR}'
		export AS='${TOOLCHAIN_AS}'
		export NM='${TOOLCHAIN_NM}'
		export RANLIB='${TOOLCHAIN_RANLIB}'
		export STRIP='${TOOLCHAIN_STRIP}'
		export OBJCOPY='${TOOLCHAIN_OBJCOPY}'
		export OBJDUMP='${TOOLCHAIN_OBJDUMP}'
		export READELF='${TOOLCHAIN_READELF}'

		export LD_LIBRARY_PATH='${LD_LIBRARY_PATH}${PKG_LD_LIBRARY_PATH:+:${PKG_LD_LIBRARY_PATH}}'
		export PATH='${PATH}'
	EOF

	case ${TARGET_ENV} in
		cross|native)
			cat <<-EOF >> environment.source
				export PKG_CONFIG='$(which pkg-config)'
				export PKG_CONFIG_LIBDIR=${TOOLCHAIN_PATH}/lib/pkgconfig:${GLOBAL_TOOLCHAIN_PATH}/lib/pkgconfig:/usr/lib64/pkgconfig
				export PKG_CONFIG_SYSROOT_DIR=
				export PKG_CONFIG_ALLOW_CROSS=
			EOF
		;;
		target)
			cat <<-EOF >> environment.source
				export PKG_CONFIG='$(which ${HARCH}-pkg-config)'
				export PKG_CONFIG_LIBDIR='${COMMON_PKG_CONFIG_LIBDIR}'
				export PKG_CONFIG_SYSROOT_DIR='${PKG_CONFIG_SYSROOT_DIR:-${COMMON_PKG_CONFIG_SYSROOT}}'
				export PKG_CONFIG_ALLOW_CROSS='${PKG_CONFIG_ALLOW_CROSS}'
			EOF
			if [ -f ${TOOLCHAIN_PATH}/venv-${HARCH}/bin/activate ]
			then
				echo -e "\nsource ${TOOLCHAIN_PATH}/venv-${HARCH}/bin/activate\n" >> environment.source
			fi
		;;
	esac

	cat <<-EOF >> environment.source

		export PYTHONPATH=${PYTHONPATH}

		export CARGO_HOME='${CARGO_HOME}'
		export RUSTUP_HOME='${RUSTUP_HOME}'

		export QEMU_LD_PREFIX='${SYSROOT}'
		export QEMU_LD_LIBRARY_PATH='${QEMU_LD_LIBRARY_PATH}'

		export ENVIRONMENT_SOURCE_PATH='${PWD}'
	EOF
	if [ "$(basename ${CCWRAPPER:-nope})" == "sccache" ]
	then
		cat <<-EOF >> environment.source
			
			# sccache parameters
			export RUSTC_WRAPPER='${CCWRAPPER}'
			export SCCACHE_DIR='${SCCACHE_DIR}'
			export SCCACHE_CACHE_SIZE='${SCCACHE_CACHE_SIZE}'
			export SCCACHE_NO_DAEMON='${SCCACHE_NO_DAEMON}'
		EOF
	fi
}

function preparesources () {
	trap 'STATUS=${?} \
		echo "preparesources fail."; \
		trap - ERR; \
		trap - SIGINT; \
		#[ -d ${PKG_SRCPATH} ] && run_cmd "rm -rf ${PKG_SRCPATH}" || true; \
		return ${STATUS};' ERR

	trap 'trap - ERR; \
		trap - SIGINT; \ 
		[ -d ${PKG_SRCPATH} ] && run_cmd "rm -rf ${PKG_SRCPATH}" || true; \
		return 100' SIGINT

	cd ${PKG_SRCPATH}
	if [ "x${PATCHDEB}" != "x" ]
	then
		echo -n "${SPACES}Retrieve DEB patch info..."
		[ ! -d ${PKG_SRCPATH}/debian ] && mkdir -p ${PKG_SRCPATH}/debian
		run_cmd "ARCHIVEDIRS=\"debian\" download_uncompress \"${PATCHDEB}\" ${PKG_SRCPATH}/debian"
		echo "Done."
		if [ -f ${PKG_SRCPATH}/debian/patches/series ]
		then
			while read patch
			do
				if [[ ! "${patch}" =~ ^\#.*|^//.* ]]
				then
					local PATCHARRAY=(${patch})
					if [ ! -z ${PATCHARRAY[0]} ]
					then
						echo -n "${SPACES}Applying ${PATCHARRAY[0]} patch..."
						run_cmd "patch ${PATCHARRAY[1]:--p1} < ${PKG_SRCPATH}/debian/patches/${PATCHARRAY[0]}"
						echo "Done."
					fi
				fi
			done <${PKG_SRCPATH}/debian/patches/series
		else
			echo "${SPACES}\"series\" patch list file does not exist."
		fi
	fi
	IFS=,
	for scanpatch in ${PATCHES:-}
	do
		if [[ ${scanpatch} =~ ^https?://|^ftp:// ]]
		then
			echo -n "${SPACES}Downloading patch[set]..."	
			NODELETEDESTDIR=1 download_uncompress ${scanpatch} ${PKG_SRCPATH}/bbxb_patches
		else
			echo -n "${SPACES}Copying $scanpatch patch..."
			run_cmd "mkdir -pv ${PKG_SRCPATH}/bbxb_patches"
			run_cmd "cp -v ${PATCH_PATH}/$scanpatch ${PKG_SRCPATH}/bbxb_patches"
		fi
	done
	unset IFS
	if [ -d ${PKG_SRCPATH}/bbxb_patches ]
	then
		find ${PKG_SRCPATH}/bbxb_patches -type f | xargs -I{} -d'\n' -n1 bash -c "
			PATCH=\"\$(basename {})\"
			echo -n \"Applying \${PATCH} patch...\"
			echo \"\$ patch -p1 < {}\"
			patch -f -p1 < \"{}\" >> ${LOG_FILE} 2>&1
			echo "Done."
		"
	fi
	if [ -f "${PKG_SRCPATH}/${CONF_CMD}" ] && [ ! -x "${PKG_SRCPATH}/${CONF_CMD}" ]
	then
		run_cmd "chmod +x ${PKG_SRCPATH}/${CONF_CMD}" >> ${LOG_FILE}
	fi
	echo -n "${SPACES}"
	cd ${BB_HOME}
	trap - ERR
	trap - SIGINT
}

function downloadonly () {
	if [ -d ${PKG_BLDPATH} ]
	then
		cd ${PKG_BLDPATH}
		echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
		create_environment_source
		source environment.source
	fi
}

function configmake () {	
	trap 'local CMDERR="${BASH_COMMAND}" STATUS=${?}; \
		echo "fail. [configmake]"; \
		echo ${CMDERR}; \
		echo; \
		trap - ERR; \
		return ${STATUS}' ERR
	if [ "${PKG_AUTOCONF:-0}" != "0" ]
	then
		if [ "${PKG_AUTOCONF:-0}" == "1" ]
		then
			PKG_AUTOCONF=${AUTOCONF_VER}
		fi
		echo "# Setting up ${PKG_AUTOCONF:-${AUTOCONF_VER}} ${PKG_AUTOMAKE:-${AUTOMAKE_VER}} ${PKG_LIBTOOL:-${LIBTOOL_VER}} ${PKG_GETTEXT:-${GETTEXT_VER}}"
		setup_autotools ${PKG_AUTOCONF:-${AUTOCONF_VER}} ${PKG_AUTOMAKE:-${AUTOMAKE_VER}} ${PKG_LIBTOOL:-${LIBTOOL_VER}} ${PKG_GETTEXT:-${GETTEXT_VER}}
		if [ "${AUTOCONF_PATH}" == "autoscan" ]
		then
			if [ ${PKG_COPYSRC:-0} -eq 0 ]
			then
				pushd ${PKG_SRCPATH}
			else
				pushd ${PKG_BLDPATH}
			fi
			AUTOCONF_PATH="$(find . -name "configure.ac" -printf '%P\n' | xargs dirname | sort | tr '\n' ',' | sed 's/,$//' )"
			echo "Scanned AUTOCONF_PATH: ${AUTOCONF_PATH}"
			popd
		fi
		#### Multi process autoreconf 
		echo -n "${AUTOCONF_PATH:-.}" | xargs --verbose -P${AUTOCONF_THREADS:-${NPROCS}} -d',' -I{} bash -c "PKG_AUTOMAKE=${PKG_AUTOMAKE} smart_autoreconf ${PKG_SRCPATH}/{} || exit 255"
	fi
	run_cmd "mkdir -p ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}"
	pushd ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}
	if [ ${STD_CONF_FLAGS:-1} -eq 1 ]
	then
		CONF_FLAGS="--prefix=${INSTALL_PREFIX} --exec-prefix=${INSTALL_EXECPREFIX} --libdir=${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX} \
					--includedir=${INSTALL_INCLUDEDIR} --sysconfdir=${INSTALL_SYSCONFDIR} --localstatedir=${INSTALL_LOCALSTATEDIR} \
					${CONF_FLAGS}"
		if [ ${BUILD_LIBSHARED} -eq 1 ]
		then
			CONF_FLAGS=" --enable-shared ${CONF_FLAGS}"
		else
			CONF_FLAGS=" --disable-shared ${CONF_FLAGS}"
		fi
		if [ ${BUILD_LIBSTATIC} -eq 1 ]
		then
			CONF_FLAGS=" --enable-static ${CONF_FLAGS}"
		else
			CONF_FLAGS=" --disable-static ${CONF_FLAGS}"
		fi
		case ${PKG_TARGET_ENV} in
			native)
				CONF_FLAGS="--build=${BARCH} --host=${BARCH} ${CONF_FLAGS}"
			;;
			cross)
				CONF_FLAGS="--build=${BARCH} --host=${BARCH} ${CONF_FLAGS}"
			;;
			target)
				CONF_FLAGS="--build=${BARCH} --host=${HARCH} --with-sysroot=${BIN_PATH} ${CONF_FLAGS}"
			;;
		esac
	fi
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	if [[ "${CONF_CMD}" =~ ^\./.* ]]
	then
		local RUNCONFIG_CMD="${CONF_CMD}"
	else
		if [ ${PKG_COPYSRC:-0} -eq 0 ]
		then
			local RUNCONFIG_CMD="${PKG_SRCPATH}${CONF_PATH:+/${CONF_PATH}}/${CONF_CMD:-configure}"
		else
			local RUNCONFIG_CMD="${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}/${CONF_CMD:-configure}"
		fi
	fi
	cat >runconfig.sh <<-EOF
		#!/bin/bash -x
		${CONF_ENV} ${RUNCONFIG_CMD} ${CONF_FLAGS} ${CONF_VARS} \${@}
	EOF
	cat >runmake.sh <<-EOF
		#!/bin/bash -x
		${PKG_MAKEENV} ${GLOBAL_TOOLCHAIN_PATH}/bin/make V=${MAKEVERBOSE:-0} ${PKG_MAKEVARS} \${@}
	EOF
	run_cmd "chmod +x runconfig.sh runmake.sh"

	#if [[ "${CONF_CMD}" =~ ^\./.* ]]
	#then
	#	run_cmd "${CONF_CMD} ${CONF_FLAGS}"
	#else 
	#	run_cmd "${PKG_SRCPATH}${CONF_PATH:+/${CONF_PATH}}/${CONF_CMD:-configure} ${CONF_FLAGS}"
	#fi
	run_cmd "./runconfig.sh"
	if [ ${PKG_TWOSTEPSBUILD:-1} -eq 1 ] || [ -n "${PKG_MAKETARGETS}" ]
	then
		IFS=,
		for target in ${PKG_MAKETARGETS:-all}
		do
			unset IFS
			echo "Making ${target}..."
			run_cmd "./runmake.sh ${target}"
		done
		unset IFS
	fi
	if [ ${PKG_SKIPINSTALL:-0} -eq 0 ]
	then
		run_cmd "./runmake.sh ${INST_CMD:-} DESTDIR=${PKG_PKGPATH}"
	fi
	popd
	trap - ERR
}

function simplemake () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR
	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	cat >runmake.sh <<-EOF
		#!/bin/bash -x
		${PKG_MAKEENV} ${GLOBAL_TOOLCHAIN_PATH}/bin/make V=${MAKEVERBOSE:-0} PREFIX=${INSTALL_PREFIX} LIBSUFFIX=${INSTALL_LIBSUFFIX} ${PKG_MAKEVARS} \${@}
	EOF
	run_cmd "chmod +x runmake.sh"
	if [ ${PKG_TWOSTEPSBUILD:-1} -eq 1 ] || [ ! -x ${PKG_MAKETARGETS} ]
	then
		IFS=,
		for target in ${PKG_MAKETARGETS:-all}
		do
			unset IFS
			echo "Making ${target}..."
			run_cmd "./runmake.sh ${target}"
		done
		unset IFS
	fi
	if [ ${PKG_SKIPINSTALL:-0} -eq 0 ]
	then
		run_cmd "./runmake.sh ${INST_CMD:-install} DESTDIR=${PKG_PKGPATH} "
	fi
	cd ${BB_HOME}
	trap - ERR
}

function cmakebuild () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	run_cmd "mkdir -p ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}"
	cd ${PKG_BLDPATH}
	if [ ${BUILD_LIBSHARED} -eq 1 ]
	then
		CONF_FLAGS+=" -DBUILD_SHARED_LIBS=ON"
	else
		CONF_FLAGS+=" -DBUILD_SHARED_LIBS=OFF"
	fi
	if [ ${BUILD_LIBSTATIC} -eq 1 ]
	then
		CONF_FLAGS+=" -DBUILD_STATIC_LIBS=ON"
	else
		CONF_FLAGS+=" -DBUILD_STATIC_LIBS=OFF"
	fi
	local NINJA_FLAGS="$([ $MAKEVERBOSE -eq 1 ] && echo -n ' -v')"
	echo "CCWRAPPER=\"\" create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	CCWRAPPER="" create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source

	cat >runconfig.sh <<-EOF
		#!/bin/bash -x
		${CONF_ENV} ${GLOBAL_TOOLCHAIN_PATH}/bin/cmake ${PKG_SRCPATH} \\
		   -G Ninja \\
		   -DCMAKE_BUILD_TYPE="Release" \\
		   -DTOOLCHAIN_PREFIX=${HARCH}- \\
		   -DCMAKE_C_COMPILER_LAUNCHER=${CCWRAPPER} \\
		   -DCMAKE_CXX_COMPILER_LAUNCHER=${CCWRAPPER} \\
		   -DCMAKE_AR=${AR} \\
		   -DCMAKE_RANLIB=${RANLIB} \\
		   -DCMAKE_CROSSCOMPILING="True" \\
		   -DCMAKE_INSTALL_PREFIX="${INSTALL_PREFIX}" \\
		   -DCMAKE_INSTALL_LIBDIR="${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}" \\
		   -DLIB_SUFFIX="${INSTALL_LIBSUFFIX}" \\
		   -DCMAKE_INSTALL_INCLUDEDIR="${INSTALL_INCLUDEDIR}" \\
		   -DCMAKE_INSTALL_SYSCONFDIR="${INSTALL_SYSCONFDIR}" \\
		   -DCMAKE_INSTALL_DATADIR="${INSTALL_SHAREDIR}" \\
		   ${CONF_FLAGS}
	EOF
	cat >runmake.sh <<-EOF
		#!/bin/bash -x
		${PKG_MAKEENV} DESTDIR=${PKG_PKGPATH} ${GLOBAL_TOOLCHAIN_PATH}/bin/ninja ${NINJA_FLAGS} ${PKG_MAKEVARS} \${@}
	EOF
	run_cmd "chmod +x runconfig.sh runmake.sh"
	run_cmd "./runconfig.sh"
	run_cmd "./runmake.sh -j${NPROCS} ${PKG_MAKETARGETS}"
	if [ ${PKG_SKIPINSTALL:-0} -eq 0 ]
	then
		run_cmd "./runmake.sh -j${NPROCS} ${INST_CMD:-install}"
	fi
	cd ${BB_HOME}
	trap - ERR
}

function mesonninja () {
	function createmesoncross () {	
		function buildmesonargs () {
			local FIRST=1
			for flag in ${1}
			do
				if [ ${FIRST} -ne 1 ]
				then
					echo -n ", "
				fi
				echo -n "'${flag}'"
			local FIRST=0
			done
			echo
		}
		local C=$(buildmesonargs "${CC}")
		local C_ARGS=$(buildmesonargs "${CFLAGS}")
		local C_LINK_ARGS=$(buildmesonargs "${LDFLAGS}")
		local CPP=$(buildmesonargs "${CXX}")
		local CPP_ARGS=$(buildmesonargs "${CXXFLAGS}")
		local CPP_LINK_ARGS=$(buildmesonargs "${LDFLAGS}")
		if [ ! -z "${FC}" ]
		then
			local FORTRAN=$(buildmesonargs "${FC}")
			local FORTRAN_ARGS=$(buildmesonargs "${FFLAGS}")
			local FORTRAN_LINK_ARGS=$(buildmesonargs "${LDFLAGS}")
		fi
		cat > cross-${PLATFORM_NAME} <<-EOF
			[binaries]
			c = [${C}]
			c_ld = '$(echo ${LD} | sed "s/ld.//;s/${HARCH}-//" )'
			cpp = [${CPP}]
			cpp_ld = '$(echo ${LD} | sed "s/ld.//;s/${HARCH}-//" )'
			fortran = [${FORTRAN}]
			ar = '${AR}'
			strip = '${STRIP}'
			nm = '${NM}'
			ranlib = '${RANLIB}'
			pkgconfig = '${PKG_CONFIG}'
			python = '$(which cross-python3)'
			exe_wrapper = 'qemu-${HM}-static'

			[host_machine]
			system = '${HOS}'
			cpu_family = '${HM}'
			cpu = '${HMCPU}'
			endian = '${HMENDIAN}'

			[properties]
			sys_root = '${SYSROOT}'
			c_args = [${C_ARGS}]
			cpp_args = [${CPP_ARGS}]
			fortran_args= [${FORTRAN_ARGS}]
			c_link_args = [${C_LINK_ARGS}]
			cpp_link_args = [${CPP_LINK_ARGS}]
			fortran_link_args = [${FORTRAN_LINK_ARGS}]
		EOF
		run_cmd "cat cross-${PLATFORM_NAME}"
	}

	trap 'STATUS=${?}; \
		trap - ERR; \
		echo "fail. [mesonninja - ${PKG_NAME}]"; \
		echo; \
		return ${STATUS}' ERR

	run_cmd "mkdir -p ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	if [ ${STD_CONF_FLAGS:-1} -eq 1 ]
	then
		CONF_FLAGS="--prefix=${INSTALL_PREFIX} --libdir=${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX} --includedir=${INSTALL_INCLUDEDIR} \
			--sysconfdir=${INSTALL_SYSCONFDIR} --localstatedir=${INSTALL_LOCALSTATEDIR} --datadir=${INSTALL_SHAREDIR} ${CONF_FLAGS}"
		if [ ${BUILD_LIBSHARED} -eq 0 ] && [ ${BUILD_LIBSTATIC} -eq 1 ]
		then
			CONF_FLAGS+=" --default-library=static"
		fi
		if [ ${BUILD_LIBSHARED} -eq 1 ] && [ ${BUILD_LIBSTATIC} -eq 0 ]
		then
			CONF_FLAGS+=" --default-library=shared"
		fi
	fi
	local RUNCONFIG_CMD="${GLOBAL_TOOLCHAIN_PATH}/bin/meson ${PKG_SRCPATH} ${PKG_BLDPATH} --buildtype=release -Db_ndebug=true -Db_pie=true"
	case ${PKG_OVERRIDELTO:-${LTOENABLE:-0}} in
		0) ;;
		*) RUNCONFIG_CMD+=" -Db_lto=true" ;;
	esac
	local NINJA_FLAGS="$([ $MAKEVERBOSE -eq 1 ] && echo -n ' -v')"
	case ${PKG_TARGET} in
		cross|native) ;;
		*)
			createmesoncross
			RUNCONFIG_CMD+=" --cross-file cross-${PLATFORM_NAME}"
		;;
	esac
	cat > runconfig.sh <<-EOF
		#!/bin/bash -x
		${CONF_ENV} ${RUNCONFIG_CMD} ${CONF_FLAGS} \${@}	
	EOF
	cat >runmake.sh <<-EOF
		#!/bin/bash -x
		${PKG_MAKEENV} DESTDIR=${PKG_PKGPATH} ${GLOBAL_TOOLCHAIN_PATH}/bin/ninja ${NINJA_FLAGS} ${PKG_MAKEVARS} \${@}
	EOF
	run_cmd "chmod +x runconfig.sh runmake.sh"
	run_cmd "./runconfig.sh"
	run_cmd "./runmake.sh -j${NPROCS} ${PKG_MAKETARGETS}"
	if [ ${PKG_SKIPINSTALL:-0} -eq 0 ]
	then
		run_cmd "./runmake.sh -j${NPROCS} ${INST_CMD:-install}"
	fi
	cd ${BB_HOME}
	trap - ERR
}

function cargobuild () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	local CARGO_BIN=${CARGO_BIN:-${INSTALL_EXECPREFIX}/bin}
	local CARGO_LIB=${CARGO_LIB:-${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}}
	local CARGO_TARGET=$(echo ${HARCH} | sed 's/-/-unknown-/' )
	export CARGO_PROFILE_RELEASE_OPT_LEVEL=${OPTLEVEL}
	case ${PKG_OVERRIDELTO:-${LTOENABLE:-0}} in
		1|fat) export CARGO_PROFILE_RELEASE_LTO=fat
			;;
		2|thin)	export CARGO_PROFILE_RELEASE_LTO=thin
			;;
	esac
	for param in $(echo ${TOOLCHAIN_EXTRA_C_CMD} ${SYSROOT_FLAGS} ${STRIP_FLAG} ${OPTLINK_FLAGS} ${COMMON_LDFLAGS} ${TOOLCHAIN_LINKERFLAGS} ${PKG_LDFLAGS})
	do
		export RUSTFLAGS+=" -C link-arg=${param}"
	done
	export RUSTFLAGS+=" ${PLATFORM_RUSTSYSROOT} ${PLATFORM_RUSTFLAGS} ${OPTCOMP_RUSTFLAGS} -C linker=${TOOLCHAIN_CC}"
	echo "RUSTFLAGS=${RUSTFLAGS}" | log_buffer info
	run_cmd "cargo build $( [${MAKEVERBOSE:-0} -eq 1 ] && echo -n "--verbose" ) --release ${CONF_FLAGS} --target=${CARGO_TARGET}"
	for file in ${CARGO_BINLIST}
	do
		if [ ! -d ${PKG_PKGPATH}${CARGO_BIN} ]
		then
			run_cmd "mkdir -p ${PKG_PKGPATH}${CARGO_BIN}"
		fi
		run_cmd "cp -p target/${CARGO_TARGET}/release/${file} ${PKG_PKGPATH}${CARGO_BIN}/${file}"
	done
	for file in ${CARGO_LIBLIST}
	do
		if [ ! -d ${PKG_PKGPATH}${CARGO_LIB} ]
		then
			run_cmd "mkdir -p ${PKG_PKGPATH}${CARGO_LIB}"
		fi
		run_cmd "cp -p target/${CARGO_TARGET}/release/${file} ${PKG_PKGPATH}${CARGO_LIB}/${file}"
	done
	cd ${BB_HOME}
	trap - ERR
}

function kernelmodbuild () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}
	cd ${PKG_BLDPATH}

	if [ ! -f "${PKG_BLDPATH}/Makefile" ]
	then
		cat <<-EOF > "${PKG_BLDPATH}/Makefile"
			KDIR:=${PKG_KERNEL_BLDPATH}
			KMOD:=${PKG_BLDPATH}
			obj-m:=${PKG_KERNEL_MOD}.o
			${PKG_KERNEL_MOD}-y:=
		EOF
	fi
	run_cmd "cat ${PKG_BLDPATH}/Makefile"

	if [ ${PKG_KERNEL_LOCALBUILD:-0} -eq 0 ]
	then
		local BUILD_OPTION="-C ${PKG_KERNEL_BLDPATH} "
	fi

	run_cmd "KCFLAGS=\"${PKG_CFLAGS}\" ${PKG_KERNEL_BLDPATH}/make4kern.sh ${BUILD_OPTION}M=${PWD} ${PKG_MAKEVARS} modules"
	run_cmd "eval ${PKG_KERNEL_BLDPATH}/make4kern.sh ${BUILD_OPTION}M=${PWD} ${PKG_MAKEVARS} INSTALL_MOD_PATH=${PKG_PKGPATH} INSTALL_MOD_DIR=${PKG_KERNEL_MODPATH} ${INST_CMD:-modules_install}"
	run_cmd "rm -f ${PKG_PKGPATH}/lib/modules/*/modules.*"

	run_cmd "mkdir -pv ${PKG_PKGPATH}/postinst_scripts"
	cat <<-EOF > ${PKG_PKGPATH}/postinst_scripts/49_kernmodpost
		depmod -a ${PKG_KERNEL_VERSION}
	EOF
	run_cmd "cat ${PKG_PKGPATH}/postinst_scripts/49_kernmodpost"

	cd -
	trap - ERR
}

function kernelbuild () {
	function make4kern () {
		cat <<-EOF > make4kern.sh
			KBUILD_BUILD_TIMESTAMP='' \\
			make \\
				V=${MAKEVERBOSE:-0} \\
				CC="\${CC}" \\
				LD="\${LINKER_EXE}" \\
				AS="\${CC}" \\
				NM="\${NM}" \\
				AR="\${AR}" \\
				OBJCOPY="\${OBJCOPY}" \\
				OBJDUMP="\${OBJDUMP}" \\
				READELF="\${READELF}" \\
				STRIP="\${STRIP}" \\
				KCFLAGS="\${KCFLAGS}${LLVM_KERNELPOLLYFLAGS:+ ${LLVM_KERNELPOLLYFLAGS}}${PKG_CFLAGS:+ ${PKG_CFLAGS}}" \\
				KBUILD_LDFLAGS="${KERNEL_OPTLINK_FLAGS}${PKG_LDFLAGS:+ ${PKG_LDFLAGS}}" \\
				ARCH=${KERNEL_ARCH} \\
				CROSS_COMPILE=${HARCH}- \\
				HOSTCC="\${CC_FOR_BUILD}" \\
				HOSTCXX="\${CXX_FOR_BUILD}" \\
				HOSTAR="\${AR_FOR_BUILD}" \\
				HOSTLD="\${LINKER_EXE_FOR_BUILD}" \\
				EXTRAVERSION=${KERNEL_EXTRAVERSION} \\
				LOCALVERSION=${KERNEL_LOCALVERSION} \\
				${EXTRA_PARMS} ${PKG_MAKEVARS} \${@}
		EOF
		run_cmd "cat make4kern.sh"
		run_cmd "chmod +x make4kern.sh"
	}

	trap 'STATUS=${?}; \
		trap - ERR; \
		return ${STATUS};' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}

	echo "GCC_DEFAULT_LD=bfd  create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	GCC_DEFAULT_LD=bfd create_environment_source --target ${PKG_TARGET_ENV}
	sed -e 's/FLAGS=.*/FLAGS=/g' -e 's/PKG_CONFIG\(.*\)=.*/PKG_CONFIG\1=/' -i environment.source
	source environment.source

	make4kern

	echo "Build ${PKG_FILE} with extra modules ${PKG_KERNEL_BUILD_MODULES}"
	echo "Kernel target: ${PKG_TARGET:all}"
	# Install headers
	run_cmd "./make4kern.sh INSTALL_HDR_PATH=${PKG_PKGPATH}${INSTALL_PREFIX} headers_install"

	# Break if only headers installation required
	if [ "${PKG_TARGET}" == "headers" ]
	then
		trap - ERR
		return
	fi

	if [ -f arch/${KERNEL_ARCH}/configs/${KERNEL_DEFCONFIG} ]
	then
		run_cmd "cp -v arch/${KERNEL_ARCH}/configs/${KERNEL_DEFCONFIG} .config"
	else
		run_cmd "cp -v ${KERNEL_DEFCONFIG} .config"
	fi
	# Config kernel build

	case ${KERNEL_OPTLEVEL:-null} in
		s|S)	run_cmd "scripts/config -e CC_OPTIMIZE_FOR_SIZE -d CC_OPTIMIZE_FOR_PERFORMANCE" ;;
		2)		run_cmd "scripts/config -d CC_OPTIMIZE_FOR_SIZE -e CC_OPTIMIZE_FOR_PERFORMANCE" ;;
		3)		# Patch kernel to build with -O3 flag
				run_cmd "sed -i -e '/^ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE/i ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE_O3\nKBUILD_CFLAGS += -O3' \
					-e 's/^ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE/else ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE/' Makefile"
				run_cmd "sed -i -e \
					'/^config CC_OPTIMIZE_FOR_PERFORMANCE/i config CC_OPTIMIZE_FOR_PERFORMANCE_O3\n\tbool \"Optimize for performance (-O3)\"\n\thelp\n\t  This is the default optimization level for the kernel, building\n\t  with the \"-O2\" compiler flag for maximum performance.\n' \
					init/Kconfig"
				#run_cmd "sed -i "/depends on ARC$/d" init/Kconfig"
				run_cmd "scripts/config -d CC_OPTIMIZE_FOR_SIZE -d CC_OPTIMIZE_FOR_PERFORMANCE -e CC_OPTIMIZE_FOR_PERFORMANCE_O3"
			;;
	esac

	if [ "x${CONF_FLAGS}" != "x" ]
	then
		run_cmd "scripts/config ${CONF_FLAGS}"
	fi

	if [ ${PKG_TOOLCHAIN:-${TOOLCHAIN}} == llvm ]
	then
		echo "LTO type: ${PKG_OVERRIDELTO:-${KERNEL_LTOENABLE:-0}}"
		case ${PKG_OVERRIDELTO:-${KERNEL_LTOENABLE:-0}} in
			0)
				run_cmd "scripts/config -d LTO_CLANG -d LTO_CLANG_THIN"
				;;
			1|lto)
				run_cmd "scripts/config -d FTRACE -d FTRACE_MCOUNT_USE_RECORDMCOUNT -d KASAN -d GCOV_KERNEL"
				run_cmd "scripts/config -e LTO_CLANG"
				;;
			2|thin)
				run_cmd "scripts/config -d FTRACE -d FTRACE_MCOUNT_USE_RECORDMCOUNT -d KASAN -d GCOV_KERNEL"
				run_cmd "scripts/config -e LTO_CLANG_THIN"
				;;
		esac
	fi

	run_cmd "./make4kern.sh olddefconfig"

	if [ ! -d ${PKG_PKGPATH}/boot ]
	then
		run_cmd "mkdir -p ${PKG_PKGPATH}/boot"
	fi

	# Build and install kernel
	run_cmd "./make4kern.sh ${KERNEL_IMAGE}"
	case ${KERNEL_NAME}
	in
		kernel*)
			run_cmd "cp arch/${KERNEL_ARCH}/boot/${KERNEL_IMAGE} ${PKG_PKGPATH}/boot/${KERNEL_NAME}"
			local STATUS=${?}
			;;
		*)
			[ ! -d ${PKG_PKGPATH}/boot ] && mkdir ${PKG_PKGPATH}/boot
			run_cmd "${GLOBAL_TOOLCHAIN_PATH}/bin/make ${KERNEL_ARCH:+ARCH=${KERNEL_ARCH}} ${HARCH:+CROSS_COMPILE=${HARCH}-} INSTALL_PATH=${PKG_PKGPATH}/boot ${INST_CMD} install"
			;;
	esac
	
	# Build and install modules

	run_cmd "./make4kern.sh modules"
	run_cmd "${GLOBAL_TOOLCHAIN_PATH}/bin/make ${KERNEL_ARCH:+ARCH=${KERNEL_ARCH}} ${HARCH:+CROSS_COMPILE=${HARCH}-} INSTALL_MOD_PATH=${PKG_PKGPATH} ${INST_CMD} modules_install"
	local KERNELRELEASE=$(cat include/config/kernel.release)
	run_cmd "rm ${PKG_PKGPATH}/lib/modules/${KERNELRELEASE}/build ${PKG_PKGPATH}/lib/modules/${KERNELRELEASE}/source"

	# Build and install DTBS
	if [ ${KERNEL_DTBS:-0} -eq 1 ] && [ ${STATUS} -eq 0 ]
	then
		if [ ! -d ${PKG_PKGPATH}/boot/overlays ]
		then
			run_cmd "mkdir -p ${PKG_PKGPATH}/boot/overlays"
		fi
		run_cmd "./make4kern.sh dtbs"
		run_cmd "${GLOBAL_TOOLCHAIN_PATH}/bin/make ${KERNEL_ARCH:+ARCH=${KERNEL_ARCH}} ${HARCH:+CROSS_COMPILE=${HARCH}-} INSTALL_DTBS_PATH=${PKG_PKGPATH}/boot ${INST_CMD} dtbs_install"
	fi

	PKG_KERNEL_BLDPATH="${PWD}"
	PKG_KERNEL_VERSION="$(./make4kern.sh kernelversion)"

	IFS=,
	for module in ${PKG_KERNEL_BUILD_MODULES}
	do
		build --force ${module}
	done
	unset IFS

	cd ${BB_HOME}
	trap - ERR
}

function pythonbuild () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}
	local PYTHONBIN_VER=$(cut -d. -f1,2 <<<$(awk '{print $2}' <<<$(python -V)))
	local PYTHONBIN_MAJVER=$(cut -d. -f1 <<<${PYTHONBIN_VER})
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m ]
	then
		COMMON_CFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m"
		COMMON_CPPFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m"
	fi
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER} ]
	then
		COMMON_CFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}"
		COMMON_CPPFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}"
	fi
	if [ -f ${DISTOS_PATH}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/libpython${PYTHONBIN_VER}m ]
	then
		COMMON_LDFLAGS+=" -lpython${PYTHONBIN_VER}m"
	fi
	if [ -f ${DISTOS_PATH}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/libpython${PYTHONBIN_VER} ]
	then
		COMMON_LDFLAGS+=" -lpython${PYTHONBIN_VER}"
	fi
	if [ ${MAKEVERBOSE:-0} -eq 1 ]
	then
		local VERBOSE="-v"
	fi
	if [ -f ${DISTOS_PATH}/etc/debian_version ]
	then
		local PYTHON_PKGDIR="dist-packages"
	else
		local PYTHON_PKGDIR="site-packages"
	fi
	local INSTALL_TARGET="--install-lib=${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/${PYTHON_PKGDIR}"
	PYTHONPATH=${BIN_PATH}${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/${PYTHON_PKGDIR}
	for pythonpkgdir in python${PYTHONBIN_MAJVER} python${PYTHONBIN_VER}
	do
		if [ -d ${DISTOS_PATH}${INSTALL_LIBDIR}/${pythonpkgdir}/${PYTHON_PKGDIR} ]
		then
			PYTHONPATH+=:${DISTOS_PATH}${INSTALL_LIBDIR}/${pythonpkgdir}/${PYTHON_PKGDIR}
		fi
		export PYTHONPATH
	done
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	run_cmd "cross-python -m site"
	run_cmd "${PKG_BUILDVARS} cross-python setup.py build -j${NPROCS} ${CONF_FLAGS}"
	run_cmd "${PKG_BUILDVARS} cross-python setup.py install --root=${PKG_PKGPATH} --prefix=${INSTALL_PREFIX} --exec-prefix=${INSTALL_EXECPREFIX} ${INSTALL_TARGET}"
	cd ${BB_HOME}
	trap - ERR
}

function pythonpip () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	run_cmd "mkdir -pv ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}
	local PYTHONBIN_VER=$(cut -d. -f1,2 <<<$(awk '{print $2}' <<<$(python -V)))
	local PYTHONBIN_MAJVER=$(cut -d. -f1 <<<${PYTHONBIN_VER})
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m ]
	then
		COMMON_CFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m"
		COMMON_CPPFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m"
	fi
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER} ]
	then
		COMMON_CFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}"
		COMMON_CPPFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}"
	fi
	if [ -f ${DISTOS_PATH}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/libpython${PYTHONBIN_VER}m ]
	then
		COMMON_LDFLAGS+=" -lpython${PYTHONBIN_VER}m"
	fi
	if [ -f ${DISTOS_PATH}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/libpython${PYTHONBIN_VER} ]
	then
		COMMON_LDFLAGS+=" -lpython${PYTHONBIN_VER}"
	fi
	if [ ${MAKEVERBOSE:-0} -eq 1 ]
	then
		local VERBOSE="-v"
	fi
	if [ -f ${DISTOS_PATH}/etc/debian_version ]
	then
		local PYTHON_PKGDIR="dist-packages"
	else
		local PYTHON_PKGDIR="site-packages"
	fi
	PYTHONPATH="${BIN_PATH}${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/${PYTHON_PKGDIR}"
	for pythonpkgdir in python${PYTHONBIN_MAJVER} python${PYTHONBIN_VER}
	do
		if [ -d ${DISTOS_PATH}${INSTALL_LIBDIR}/${pythonpkgdir}/${PYTHON_PKGDIR} ]
		then
			PYTHONPATH+=":${DISTOS_PATH}${INSTALL_LIBDIR}/${pythonpkgdir}/${PYTHON_PKGDIR}"
		fi
	done
	#PYTHONUSERBASE="${PKG_PKGPATH}${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/${PYTHON_PKGDIR}"
	#export PYTHONUSERBASE
	export PYTHONPATH
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	run_cmd "cross-python -m site"
	if [ ${PKG_PYTHONBUILD:-1} -eq 1 ]
	then
		local PYTHONBUILD="--no-binary :all:"
	fi
	#build-python -m pip ${VERBOSE} install --upgrade ${PKG_NAME}
	run_cmd "cross-python -m pip ${VERBOSE} install -I ${PYTHONBUILD} --root ${PKG_PKGPATH} --prefix=${INSTALL_PREFIX} ${PKG_NAME}"
	if [ ${PYTHON_PKGDIR} == dist-packages ]
	then
		run_cmd "mv ${PKG_PKGPATH}${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/site-packages ${PKG_PKGPATH}${INSTALL_LIBDIR}/python${PYTHONBIN_VER}/dist-packages"
	fi
	cd ${BB_HOME}
	trap - ERR
}

function boostbuild () {
	trap 'STATUS=${?}; \
	trap - ERR; \
	return ${STATUS};' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	cd ${PKG_BLDPATH}
	if [ -d ${DISTOS_PATH}${INSTALL_INCLUDEDIR} ]
	then
		local ICU_INCLUDEDIR=${DISTOS_PATH}${INSTALL_INCLUDEDIR}
	else
		local ICU_INCLUDEDIR=${BIN_PATH}${INSTALL_INCLUDEDIR}
	fi
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m ]
	then
		COMMON_CXXFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}m"
	fi
	if [ -d ${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER} ]
	then
		COMMON_CXXFLAGS+=" -I${DISTOS_PATH}/usr/include/python${PYTHONBIN_VER}"
	fi
	if [ ${MAKEVERBOSE} -eq 1 ]
	then
		local B2_FLAGS="-d+2"
	else
		local B2_FLAGS="-d+1"
	fi
	if [ ${BUILD_LIBSHARED} -eq 1 ]
	then
		local B2_FLAGS="${B2_FLAGS} link=shared runtime-link=shared"
	else
		local B2_FLAGS="${B2_FLAGS} link=static runtime-link=static"
	fi
	case ${HM} in
		arm)
			local BOOST_ARCH=arm
			local BOOST_ABI=aapcs
			local BOOST_ADDRMOD=32
			;;
		aarch64)
			local BOOST_ARCH=arm
			local BOOST_ABI=aapcs
			local BOOST_ADDRMOD=64
			;;
		i386)
			local BOOST_ARCH=x86
			local BOOST_ABI=sysv
			local BOOST_ADDRMOD=32
			;;
		x86_64)
			local BOOST_ARCH=x86
			local BOOST_ABI=sysv
			local BOOST_ADDRMOD=64
			;;
		*)
			echo "Missing architecture mapping for ${HM}"
			return 1
			;;
	esac
	case ${HOS} in
		linux|android) local HMBINFMT=elf;;
		windows) local HMBINFMT=pe;;
		macosx|ios) local HMBINFMT=mach-o;;
	esac
	case ${PKG_TOOLCHAIN:-${TOOLCHAIN}} in
		llvm) 
				local BBTC=clang
				local CXX_EXE=${CCWRAPPER:+${CCWRAPPER} }clang++
				local WORKAROUND="--target=${HARCH} "
				local LINKER_FLAGS="-fuse-ld=${LLVM_DEFAULT_LD:-lld} -Wl,--threads=${NPROCS} ${LLVM_EXTRALDFLAGS}"
			;;
		gnu) 
				local BBTC=gcc
				local CXX_EXE=${CCWRAPPER:+${CCWRAPPER} }${HARCH}-g++
				local LINKER_FLAGS="-fuse-ld=${LLVM_DEFAULT_LD:-gold} ${GNU_EXTRALDFLAGS}"
			;;
	esac
	case ${OPTLEVEL} in
		2)	local OPTIMIZATION=minimal
			;;
		3)	local OPTIMIZATION=speed
			;;
		s)	local OPTIMIZATION=space
			;;
		*)	local OPTIMIZATION=off
			;;
	esac
	case ${PKG_OVERRIDELTO:-${LTOENABLE:-0}} in
		1|fat)
			local LTO=on
			local LTOMODE=full
			;;
		2|thin)
			local LTO=on
			local LTOMODE=thin
			;;
		*)
			local LTO=off
			;;
	esac
	#echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	#create_environment_source
	#source environment.source
	run_cmd "./bootstrap.sh \\
		--prefix=${PKG_PKGPATH}${INSTALL_PREFIX} \\
		--exec-prefix=${PKG_PKGPATH}${INSTALL_EXECPREFIX} \\
		--libdir=${PKG_PKGPATH}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX} \\
		--includedir=${PKG_PKGPATH}${INSTALL_INCLUDEDIR} \\
		--with-icu=${ICU_INCLUDEDIR} \\
		--with-python-version=${PYTHONBIN_VER} \\
		--with-toolset=${BBTC}"
	run_cmd "sed -i \"s|using ${BBTC} ;|using ${BBTC} : : ${CXX_EXE} ;|\" project-config.jam"
	run_cmd "./b2 -j${NPROCS} -q \\
		architecture=${BOOST_ARCH} address-model=${BOOST_ADDRMOD} \\
		binary-format=${HMBINFMT} abi=${BOOST_ABI} target-os=${HOS} \\
		variant=release optimization=${OPTIMIZATION} lto=${LTO} lto-mode=${LTOMODE} threading=multi ${B2_FLAGS} \\
		toolset=${BBTC} \\
		cflags=\"${WORKAROUND}${SYSROOT_FLAGS} ${PLATFORM_CFLAGS} ${PKG_CFLAGS}\" \\
		cxxflags=\"${COMMON_CXXFLAGS} -fPIC ${PKG_CXXFLAGS}\" \\
		linkflags=\"${WORKAROUND}${SYSROOT_FLAGS} ${LINKER_FLAGS} ${COMMON_LDFLAGS} ${PKG_LDFLAGS}\" \\
		install"
	cd ${BB_HOME}
	trap - ERR
}

function custom () {
	trap 'local CMDERR="${BASH_COMMAND}" STATUS=${?}; \
		echo "fail. [configmake]"; \
		echo ${CMDERR}; \
		echo; \
		trap - ERR; \
		return ${STATUS}' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	pushd ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	cat >runmake.sh <<-EOF
		#!/bin/bash -ex

	EOF
	echo "${PKG_BUILDSCRIPT}" >>runmake.sh
	run_cmd "chmod +x runmake.sh"
	run_cmd "./runmake.sh"
	popd
	trap - ERR
}

function perlmodule () {
	trap 'local CMDERR="${BASH_COMMAND}" STATUS=${?}; \
		echo "fail. [configmake]"; \
		echo ${CMDERR}; \
		echo; \
		trap - ERR; \
		return ${STATUS}' ERR

	run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}"
	pushd ${PKG_BLDPATH}${CONF_PATH:+/${CONF_PATH}}
	echo "create_environment_source --target ${PKG_TARGET_ENV}" | log_buffer info
	create_environment_source --target ${PKG_TARGET_ENV}
	source environment.source
	pwd
	cat > runconfig.sh <<-EOF
		#!/bin/bash

		perl Makefile.PL \\
		AR='${AR}' CC='${CC}' CPPRUN='${CPP}' FULL_AR='${AR}' LD='${CC}' \\
		PERL_INC='${SYSROOT}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/perl5/5.36/CORE' \\
	EOF
	sudo chroot ${SYSROOT} \
		perl -V | \
		grep -o '[^ ].*=.*' | \
		sed -e 's/ =/=/g' -e 's/^[a-z0-9_]*=/\U&/' -e '/=\x27/! s/=/=\x27/' -e '/\x27$/! s/$/\x27/' | \
		grep -e 'CCFLAGS=' -e 'CCCDLFLAGS=' -e 'CCDLFLAGS=' -e 'LDDLFLAGS=' -e 'LDFLAGS=' -e 'OFF_T=' | \
		xargs -d'\n' >> runconfig.sh
	run_cmd "chmod +x runconfig.sh"
	run_cmd "./runconfig.sh"
	cat > runmake.sh <<-EOF
		#!/bin/bash
		make PERL_INC='${SYSROOT}${INSTALL_LIBDIR}${INSTALL_LIBSUFFIX}/perl5/5.36/core_perl/CORE'
	EOF
	run_cmd "chmod +x runmake.sh"
	run_cmd "./runmake.sh"

	pause

	popd
	trap - ERR
}


function build () {
(
	function downloadsources () {
		trap 'STATUS=${?}; \
			trap - ERR SIGINT; \
			return ${STATUS};' ERR	
		trap 'trap - ERR SIGINT; \
			[ -d ${PKG_SRCPATH} ] && run_cmd "rm -rf ${PKG_SRCPATH}" || true;
			return 100' SIGINT

		if [ ! -z "${PKG_URL}" ]
		then
			[ -d ${PKG_SRCPATH} ] && rm -rf ${PKG_SRCPATH}
			for url in ${PKG_URL}
			do
				if [ ${MAKEDIR:-0} -eq 1 ]
				then
					NODELETEDESTDIR=1 STRIPCOMPONENTS=0 download_uncompress "${url}" "${PKG_SRCPATH}"
				else
					NODELETEDESTDIR=1 download_uncompress "${url}" "${PKG_SRCPATH}"
				fi
			done
		else
			if [ ! -z ${GIT_URL} ]
			then
				if [ ! -d ${PKG_SRCPATH} ]
				then
					run_cmd "git clone --recursive \"${GIT_URL}\" \"${PKG_SRCPATH}\""
					if  [ ! -z ${GIT_COMMIT} ]
					then
						run_cmd "git -C \"${PKG_SRCPATH}\" checkout \"${GIT_COMMIT}\""
					fi
				fi
			fi
		fi
		trap - ERR
		trap - SIGINT
	}

	trap 'STATUS=${?}; \
		trap - ERR; \
		echo "fail. [build - ${PKG_NAME}]"; \
		echo; \
		if [ -f ${LOG_FILE} ]; \
		then \
			echo "Log ${LOG_FILE}:"; \
			echo; \
			tail -n24 ${LOG_FILE}; \
		fi; \
		set +x; \
		return ${STATUS}' ERR

	unset \
		AUTOCONF_PATH \
		AUTOCONF_THREADS \
		CARGO_BIN \
		CARGO_LIB \
		CARGO_BINLIST \
		CARGO_LIBLIST \
		CONF_CMD \
		CONF_ENV \
		CONF_FLAGS \
		CONF_PATH \
		CONF_VARS \
		GIT_URL \
		GIT_COMMIT \
		INST_CMD \
		MAKEDIR \
		PATCHDEB \
		PATCHES \
		PKG_AUTOCONF \
		PKG_AUTOMAKE \
		PKG_BUILDSCRIPT \
		PKG_CFLAGS \
		PKG_COPYSRC \
		PKG_CXXFLAGS \
		PKG_DEPS \
		PKG_FAULTYCFLAGS \
		PKG_FCFLAGS \
		PKG_GETTEXT \
		PKG_KERNEL_BUILD_MODULES \
		PKG_KERNEL_MOD \
		PKG_KERNEL_MODPATH \
		PKG_LDFLAGS \
		PKG_LD_LIBRARY_PATH \
		PKG_LIBTOOL \
		PKG_LLVMPOLLYFEATURES \
		PKG_MAKEENV \
		PKG_MAKETARGETS \
		PKG_MAKEVARS \
		PKG_OVERRIDELD \
		PKG_OVERRIDELTO \
		PKG_POSTBUILD \
		PKG_POSTINSTALL \
		PKG_POSTINSTALL_PRIO \
		PKG_PREBUILD \
		PKG_RUSTFLAGS \
		PKG_SKIPINSTALL \
		PKG_SRCDIR \
		PKG_SUFFIX \
		PKG_TARGET \
		PKG_TARGET_ENV \
		PKG_TOOLCHAIN \
		PKG_TWOSTEPSBUILD \
		PKG_URL \
		PKG_VER \
		STD_CONF_FLAGS \
		VAR_INSTALL_LIBDIR \
		VAR_INSTALL_LIBSUFFIX \
		VAR_INSTALL_INCDIR \
		VAR_INSTALL_CONFDIR \

	OPTS="--force --no_gcc_check --no_save_status --temporary --keep_builddir" OPTS_WITH_VALUE="--toolchain --with_extra_modules" param2value "${@}"
	[ ${_param_v:-0} -eq 1 ] && set -x || true
	# Split dependency in Package name and its Target separated by ':'
	local PKG_FILE=$(cut -d':' -f1 <<<${_param_1})
	local PKG_TARGET=$(cut -s -d':' -f2 <<<${_param_1})
	local GCC_CHECK=${_param_no_gcc_check:-0}
	local FORCE=${_param_force:-0}
	local NOSAVESTATUS=${_param_no_save_status:-0}
	local KEEPBUILDDIR=${_param_keep_builddir:-0}
	local TEMPORARY_STATUS=

	if [ ${_param_temporary:-0} -eq 1 ]
	then
		local TEMPORARY_STATUS=.tmp
	fi

	if [ -z "${NUMSPACES}" ]
	then
		local NUMSPACES=0
	fi

	if [ ! -f ${PKG_PATH}/${PKG_FILE}.pkg ]
	then
		echo "Package ${PKG_FILE} does not exists."
		echo
		set +x
		trap - ERR;
		return 1
	fi
	
	local PKG_NAME=$(basename ${PKG_FILE})\${PKG_SUFFIX}\${PKG_VER:+_\${PKG_VER}}
	local PKG_SRCDIR=${PKG_SRCDIR:-${PKG_NAME}}
	local PKG_BLDPATH=${BLD_PATH}/${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}
	case ${PKG_TARGET} in
		native)
			local PKG_TARGET_ENV=native
			local PKG_PKGPATH=
			local INSTALL_PREFIX=${NATIVE_PREFIX}
			local INSTALL_EXECPREFIX=${NATIVE_EXECPREFIX}
			local INSTALL_LIBDIR=${NATIVE_LIBDIR}
			local INSTALL_LIBSUFFIX=
			local INSTALL_INCLUDEDIR=${NATIVE_INCLUDEDIR}
			local INSTALL_SYSCONFDIR=${NATIVE_SYSCONFDIR}
			local INSTALL_LOCALSTATEDIR=${NATIVE_LCALSTATEDIR}
			local INSTALL_SHAREDIR=${NATIVE_SHAREDIR}
		;;
		cross)
			local PKG_TARGET_ENV=cross
			local PKG_PKGPATH=
			local INSTALL_PREFIX=${CROSS_PREFIX}
			local INSTALL_EXECPREFIX=${CROSS_EXECPREFIX}
			local INSTALL_LIBDIR=${CROSS_LIBDIR}
			local INSTALL_LIBSUFFIX=
			local INSTALL_INCLUDEDIR=${CROSS_INCLUDEDIR}
			local INSTALL_SYSCONFDIR=${CROSS_SYSCONFDIR}
			local INSTALL_LOCALSTATEDIR=${CROSS_LOCALSTATEDIR}
			local INSTALL_SHAREDIR=${CROSS_SHAREDIR}
		;;
		*)
			local PKG_TARGET_ENV=target
			local PKG_PKGPATH=${PACKAGES_PATH}/${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}
			local INSTALL_PREFIX=${TARGET_PREFIX}
			local INSTALL_EXECPREFIX=${TARGET_EXECPREFIX}
			local INSTALL_LIBDIR=${TARGET_LIBDIR}
			local INSTALL_LIBSUFFIX=${TARGET_LIBSUFFIX}
			local INSTALL_INCLUDEDIR=${TARGET_INCLUDEDIR}
			local INSTALL_SYSCONFDIR=${TARGET_SYSCONFDIR}
			local INSTALL_LOCALSTATEDIR=${TARGET_LOCALSTATEDIR}
			local INSTALL_SHAREDIR=${TARGET_SHAREDIR}
		;;
	esac

	#setbuildenv
	source ${PKG_PATH}/${PKG_FILE}.pkg
	#setbuildenv

	PKG_TOOLCHAIN=${_param_toolchain:-${PKG_TOOLCHAIN}}
	PKG_KERNEL_BUILD_MODULES="${_param_with_extra_modules:-${PKG_KERNEL_BUILD_MODULES}}"

	eval local PKG_NAME=${PKG_NAME}
	eval export PKG_SRCPATH=${SRC_PATH}/${PKG_SRCDIR}
	eval export PKG_BLDPATH=${PKG_BLDPATH}
	eval export PKG_PKGPATH=${PKG_PKGPATH}

	local STATUS_FILE=${STATUS_PATH}/${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}${TEMPORARY_STATUS}
	local STATUS_FILE_DEFAULT_TARGET=${STATUS_PATH}/${PKG_NAME}
	local LOG_FILE=${LOG_PATH}/${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}.log

	echo "Package ${PKG_NAME}${PKG_TARGET:+:${PKG_TARGET}}"

	### Check if target package or default package has already built
	local PKG_CHKSUM="$( md5sum ${PKG_PATH}/${PKG_FILE}.pkg )"
	if [ -f ${STATUS_FILE_DEFAULT_TARGET} ]
	then
		local STATUS_CHK_FILE=${STATUS_FILE_DEFAULT_TARGET}
	else
		local STATUS_CHK_FILE=${STATUS_FILE}
	fi
	if [ -f ${STATUS_CHK_FILE} ] && [ ${FORCE} -eq 0 ]
	then
		if [ "${PKG_CHKSUM}" == "$( cat ${STATUS_CHK_FILE} )" ]
		then
			echo "${SPACES}Package ${PKG_NAME}${PKG_TARGET:+:${PKG_TARGET}} already built."
			echo
			trap - ERR
			return 0
		else
			rm -f ${STATUS_FILE}
		fi
	fi
	for dep in ${PKG_DEPS}
	do
		local NUMSPACES=$((NUMSPACES+1))
		local SPACES=$(for ((i = 0 ; i < ${NUMSPACES} ; i++ )); do echo -n "   "; done)
		echo -n "${SPACES}Requires "
		#echo "Called from ${PKG_FILE}"
		build \
			$( if [ ${NOSAVESTATUS} -eq 1 ] || [ "${TEMPORARY_STATUS}" == ".tmp" ]; then echo "--temporary"; fi) \
			$( if [ ${GCC_CHECK} -eq 1 ]; then echo "--no_gcc_check"; fi ) \
			${dep}$( if [ "${PKG_TARGET_ENV}" == "native" ] || [ "${PKG_TARGET_ENV}" == "cross" ]; then echo ":${PKG_TARGET_ENV}"; fi )
		local NUMSPACES=$((NUMSPACES-1))
		local SPACES=$(for ((i = 0 ; i < ${NUMSPACES} ; i++ )); do echo -n "   "; done)
	done

	eval "> ${LOG_FILE}"
	
	if [ ${GCC_CHECK} -eq 0 ] && [ "${BUILD_PROCESS}" != "none" ] && [ "${BUILD_PROCESS}" != "downloadonly" ]
	then
		check_${PKG_TOOLCHAIN:-${TOOLCHAIN}}_c
	fi

	echo -n "${SPACES}"
	# Build defaults
	### To manage source path removal at beginning or at the end...
	#if [ -d ${PKG_SRCPATH} ]
	#then
	#	rm -rf ${PKG_SRCPATH}
	#fi
	if [ ! -d ${BLD_PATH} ]
	then
		run_cmd "mkdir -p ${BLD_PATH}" >> ${LOG_FILE}
	fi
	if [ ! -d ${BIN_PATH} ]
	then
		run_cmd "mkdir -p ${BIN_PATH}" >> ${LOG_FILE}
	fi
	echo "Pre build script:" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo "${PKG_PREBUILD}" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo >> ${LOG_FILE}
	echo "Post build script:" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo "${PKG_POSTBUILD}" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo >> ${LOG_FILE}
	echo "Post install script:" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo "${PKG_POSTINSTALL}" >> ${LOG_FILE}
	echo "==================" >> ${LOG_FILE}
	echo >> ${LOG_FILE}

	if [ ! -z "${PKG_URL}" ] || [ ! -z "${GIT_URL}" ] || [ "${BUILD_PROCESS}" == "pythonpip" ]
	then
		echo -n "Downloading ${PKG_NAME}..."
		downloadsources >> ${LOG_FILE}
		echo "Done."
		preparesources >> ${LOG_FILE}
	fi
	if [ -d ${PKG_BLDPATH} ]
	then
		run_cmd "rm -rf ${PKG_BLDPATH}" >> ${LOG_FILE}
	fi
	if [ ! -z ${PKG_PKGPATH} ]
	then
		if [ -d ${PKG_PKGPATH} ]
		then
			run_cmd -s "rm -rf ${PKG_PKGPATH}" >> ${LOG_FILE}
		fi
		run_cmd "mkdir -p ${PKG_PKGPATH}" >> ${LOG_FILE}
	fi
	if [ -n "${PKG_PREBUILD}" ]
	then
		if [ -d ${PKG_SRCPATH} ]
		then
			cd ${PKG_SRCPATH}
		fi
		echo "Running pre build script..." | log_buffer info >> ${LOG_FILE}
		(run_cmd "set -x
			set +o pipefail
			${PKG_PREBUILD}
			set +x") >> ${LOG_FILE}
	fi
	if [ ${PKG_COPYSRC:-0} -eq 1 ] 
	then
		run_cmd "cp -rp ${PKG_SRCPATH} ${PKG_BLDPATH}" >> ${LOG_FILE}
	fi
	if [ ! ${BUILD_PROCESS:-none} == none ]
	then
		echo -n "${SPACES}Building ${PKG_NAME}${PKG_TARGET:+:${PKG_TARGET}} [${BUILD_PROCESS}]..."
		${BUILD_PROCESS} >> ${LOG_FILE} 2>&1
	fi
	if [ -n "${PKG_POSTBUILD}" ]
	then
		if [ ! -d ${PKG_BLDPATH} ]
		then
			run_cmd "mkdir -p ${PKG_BLDPATH}" >> ${LOG_FILE}
		fi
		cd ${PKG_BLDPATH}
		echo "Running post build script..." | log_buffer info >> ${LOG_FILE}
		(run_cmd "set -ex
			set +o pipefail
			${PKG_POSTBUILD} 2>&1
			set +ex") >> ${LOG_FILE}
	fi
	#run_cmd "rm -rf ${PKG_SRCPATH}"

	if [ -n "${PKG_POSTINSTALL}" ]
	then
		run_cmd "mkdir -p ${PKG_PKGPATH}/postinst_scripts" >> ${LOG_FILE}
		echo "${PKG_POSTINSTALL}" > ${PKG_PKGPATH}/postinst_scripts/${PKG_POSTINSTALL_PRIO:-50}_${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}
		run_cmd "cat ${PKG_PKGPATH}/postinst_scripts/${PKG_POSTINSTALL_PRIO:-50}_${PKG_NAME}${PKG_TARGET:+-${PKG_TARGET}}" >> ${LOG_FILE}
	fi

	##### Create package
	if [ ! -z ${PKG_PKGPATH} ]
	then
		(
			set -e
			pwd
			if [ ${NOSAVESTATUS} -eq 0 ] && [ -z "${TEMPORARY_STATUS}" ]
			then
				create_sfx_package ${PKG_PKGPATH}
			fi
			run_cmd "rsync -aK --devices --specials ${PKG_PKGPATH}/ ${BIN_PATH}"
			run_cmd -s "rm -rf ${PKG_PKGPATH}"
			set +e
		) >> ${LOG_FILE} 2>&1
	fi
	if [ ${KEEPBUILDDIR} -eq 0 ]
	then
		run_cmd "rm -rf ${PKG_BLDPATH}" >> ${LOG_FILE}
	fi
	### Save build status
	if [ ! -d ${STATUS_PATH} ]
	then
		run_cmd "mkdir -p ${STATUS_PATH}" >> ${LOG_FILE}
	fi
	if [ ${NOSAVESTATUS} -eq 0 ]
	then
		run_cmd "md5sum ${PKG_PATH}/${PKG_FILE}.pkg > ${STATUS_FILE}" >> ${LOG_FILE}
	else
		run_cmd "rm -f ${STATUS_PATH}/*.tmp" >> ${LOG_FILE}
	fi
	set +x
	echo "Done."
	echo
	trap - ERR
)
}

function is_build_functions () {
	return 0
}
